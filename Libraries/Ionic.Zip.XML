<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Ionic.Zip</name>
  </assembly>
  <members>
    <member name="T:Ionic.Zip.WinZipAesCrypto">
      <summary> 
            This is a helper class supporting WinZip AES encryption.  
            This class is intended for use only by the DotNetZip library.
            </summary>
      <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            WinZipAesCrypto class.  Instead, the WinZipAesCrypto class is instantiated and used by
            the ZipEntry() class when WinZip AES encryption or decryption on an entry is employed.
            </remarks>
    </member>
    <member name="T:Ionic.Zip.WinZipAesCipherStream">
      <summary>
            A stream that encrypts as it writes, or decrypts as it reads.  The Crypto is AES in 
            CTR (counter) mode, which is 
            compatible with the AES encryption employed by WinZip 12.0.
            </summary>
    </member>
    <member name="M:Ionic.Zip.WinZipAesCipherStream.#ctor(System.IO.Stream,Ionic.Zip.WinZipAesCrypto,System.Int64,Ionic.Zip.CryptoMode)">
      <summary>
            The constructor.
            </summary>
      <param name="s">The underlying stream</param>
      <param name="mode">To either encrypt or decrypt.</param>
      <param name="cryptoParams">The pre-initialized WinZipAesCrypto object.</param>
      <param name="length">The maximum number of bytes to read from the stream.</param>
    </member>
    <member name="P:Ionic.Zip.WinZipAesCipherStream.FinalAuthentication">
      <summary>
            Returns the final HMAC-SHA1-80 
            </summary>
    </member>
    <member name="T:Ionic.Zip.CRC32">
      <summary>
            Calculates a 32bit Cyclic Redundancy Checksum (CRC) using the
            same polynomial used by Zip. This type is used internally by DotNetZip; it is generally not used directly
            by applications wishing to create, read, or manipulate zip archive files.
            </summary>
    </member>
    <member name="M:Ionic.Zip.CRC32.GetCrc32(System.IO.Stream)">
      <summary>
            Returns the CRC32 for the specified stream.
            </summary>
      <param name="input">The stream over which to calculate the CRC32</param>
      <returns>the CRC32 calculation</returns>
    </member>
    <member name="M:Ionic.Zip.CRC32.GetCrc32AndCopy(System.IO.Stream,System.IO.Stream)">
      <summary>
            Returns the CRC32 for the specified stream, and writes the input into the output stream.
            </summary>
      <param name="input">The stream over which to calculate the CRC32</param>
      <param name="output">The stream into which to deflate the input</param>
      <returns>the CRC32 calculation</returns>
    </member>
    <member name="M:Ionic.Zip.CRC32.ComputeCrc32(System.Int32,System.Byte)">
      <summary>
            Get the CRC32 for the given (word,byte) combo. 
            This is a computation defined by PKzip.
            </summary>
      <param name="W">The word to start with.</param>
      <param name="B">The byte to combine it with.</param>
      <returns>The CRC-ized result.</returns>
    </member>
    <member name="M:Ionic.Zip.CRC32.SlurpBlock(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Update the value for the running CRC32 using the given block of bytes.
            This is useful when using the CRC32() class in a Stream.
            </summary>
      <param name="block">block of bytes to slurp</param>
      <param name="offset">starting point in the block</param>
      <param name="count">how many bytes within the block to slurp</param>
    </member>
    <member name="P:Ionic.Zip.CRC32.TotalBytesRead">
      <summary>
            indicates the total number of bytes read on the CRC stream.
            This is used when writing the ZipDirEntry when compressing files.
            </summary>
    </member>
    <member name="P:Ionic.Zip.CRC32.Crc32Result">
      <summary>
            Indicates the current CRC for all blocks slurped in.
            </summary>
    </member>
    <member name="T:Ionic.Zip.CrcCalculatorStream">
      <summary>
             A Stream that calculates a CRC32 (a checksum) on all bytes read, 
             or on all bytes written.
             </summary>
      <remarks>
        <para>
             This class can be used to verify the CRC of a ZipEntry when reading from a stream, 
             or to calculate a CRC when writing to a stream.  The stream should be used to either 
             read, or write, but not both.  If you intermix reads and writes, the results are
             not defined. 
             </para>
        <para>This class is intended primarily for use internally by the DotNetZip library.</para>
      </remarks>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.#ctor(System.IO.Stream)">
      <summary>
            The constructor.
            </summary>
      <param name="stream">The underlying stream</param>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.#ctor(System.IO.Stream,System.Int64)">
      <summary>
            The constructor.
            </summary>
      <param name="stream">The underlying stream</param>
      <param name="length">The length of the stream to slurp</param>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read from the stream
            </summary>
      <param name="buffer">the buffer to read</param>
      <param name="offset">the offset at which to start</param>
      <param name="count">the number of bytes to read</param>
      <returns>the number of bytes actually read</returns>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write to the stream. 
            </summary>
      <param name="buffer">the buffer from which to write</param>
      <param name="offset">the offset at which to start writing</param>
      <param name="count">the number of bytes to write</param>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Not implemented.
            </summary>
      <param name="offset">N/A</param>
      <param name="origin">N/A</param>
      <returns>N/A</returns>
    </member>
    <member name="M:Ionic.Zip.CrcCalculatorStream.SetLength(System.Int64)">
      <summary>
            Not implemented.
            </summary>
      <param name="value">N/A</param>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.TotalBytesSlurped">
      <summary>
             Gets the total number of bytes run through the CRC32 calculator.
             </summary>
      <remarks>
             This is either the total number of bytes read, or the total number
             of bytes written, depending on the direction of this stream.
             </remarks>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.Crc32">
      <summary>
            Provides the current CRC for all blocks slurped in.
            </summary>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.CanRead">
      <summary>
            Indicates whether the stream supports reading. 
            </summary>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.CanSeek">
      <summary>
            Indicates whether the stream supports seeking. 
            </summary>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.CanWrite">
      <summary>
            Indicates whether the stream supports writing. 
            </summary>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.Length">
      <summary>
            Not implemented.
            </summary>
    </member>
    <member name="P:Ionic.Zip.CrcCalculatorStream.Position">
      <summary>
            Not implemented.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipException">
      <summary>
            Base class for all exceptions defined by and throw by the Zip library.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadPasswordException">
      <summary>
            Issued when an <c>ZipEntry.ExtractWithPassword()</c> method is invoked
            with an incorrect password.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadPasswordException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadReadException">
      <summary>
            Indicates that a read was attempted on a stream, and bad or incomplete data was
            received.  
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadReadException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadCrcException">
      <summary>
            Issued when an CRC check fails upon extracting an entry from a zip archive.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadCrcException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.SfxGenerationException">
      <summary>
            Issued when errors occur saving a self-extracting archive.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.SfxGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.BadStateException">
      <summary>
            Indicates that an operation was attempted on a ZipFile which was not possible
            given the state of the instance. For example, if you call <c>Save()</c> on a ZipFile 
            which has no filename set, you can get this exception. 
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor">
      <summary>
            Default ctor.
            </summary>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.String)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.String,System.Exception)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="message">The message in the exception.</param>
      <param name="innerException">The innerException for this exception.</param>
    </member>
    <member name="M:Ionic.Zip.BadStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Come on, you know how exceptions work. Why are you looking at this documentation?
            </summary>
      <param name="serializationInfo">The serialization info for the exception.</param>
      <param name="streamingContext">The streaming context from which to deserialize.</param>
    </member>
    <member name="T:Ionic.Zip.SharedUtilities">
      <summary>
            Collects general purpose utility methods.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.#ctor">
            private null constructor
        </member>
    <member name="M:Ionic.Zip.SharedUtilities.RoundToEvenSecond(System.DateTime)">
      <summary>
             Round the given DateTime value to an even second value.  
             </summary>
      <remarks>
        <para>
             Round up in the case of an odd second value.  The rounding does not consider fractional seconds.
             </para>
        <para>
             This is useful because the Zip spec allows storage of time only to the nearest even second.
             So if you want to compare the time of an entry in the archive with it's actual time in the filesystem, you 
             need to round the actual filesystem time, or use a 2-second threshold for the  comparison. 
             </para>
        <para>
             This is most nautrally an extension method for the DateTime class but this library is 
             built for .NET 2.0, not for .NET 3.5;  This means extension methods are a no-no.  
             </para>
      </remarks>
      <param name="source">The DateTime value to round</param>
      <returns>The ruonded DateTime value</returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.TrimVolumeAndSwapSlashes(System.String)">
      <summary>
            Utility routine for transforming path names. 
            </summary>
      <param name="pathName">source path.</param>
      <returns>transformed path</returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.FindSignature(System.IO.Stream,System.Int32)">
      <summary>
            Finds a signature in the zip stream. This is useful for finding 
            the end of a zip entry, for example. 
            </summary>
      <param name="stream">
      </param>
      <param name="SignatureToFind">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.StringToMemoryStream(System.String)">
      <summary>
            Creates a <c>MemoryStream</c> for the given string. This is used internally by Library, specifically by 
            the ZipFile.AddStringAsFile() method.   But it may be useful in other scenarios. 
            </summary>
      <param name="s">The string to use as input for the MemoryStream</param>
      <returns>the MemoryStream. Reading the stream will give you the content of the String.</returns>
    </member>
    <member name="M:Ionic.Zip.SharedUtilities.GetTempFilename">
      <summary>
            Return a random filename, suitable for use as a temporary file.
            </summary>
      <remarks>
            The System.IO.Path.GetRandomFileName() method is not available on the Compact
            Framework, so this library provides its own substitute. 
            </remarks>
      <returns>a filename of the form DotNetZip-xxxxxxxx.tmp, where xxxxxxxx is replaced 
            by randomly chosen characters.</returns>
    </member>
    <member name="T:Ionic.Zip.CountingStream">
      <summary> 
            A Stream wrapper, used for bookkeeping on input or output
            streams.  In some cases, it is not possible to get the Position
            of a stream, let's say, on a write-only output stream like
            ASP.NET's Response.Output, or on a different write-only stream
            provided as the destination for the zip by the application.
            In this case, we can use this counting stream to count the bytes
            read or written.
            </summary>
    </member>
    <member name="M:Ionic.Zip.CountingStream.#ctor(System.IO.Stream)">
      <summary>
            The  constructor.
            </summary>
      <param name="s">The underlying stream</param>
    </member>
    <member name="T:Ionic.Zip.ZipCrypto">
      <summary> 
            This class implements the "traditional" or "classic" PKZip encryption,
            which today is considered to be weak. On the other hand it is
            ubiquitous. This class is intended for use only by the DotNetZip library.
            </summary>
      <remarks>
            Most uses of the DotNetZip library will not involve direct calls into the
            ZipCrypto class.  Instead, the ZipCrypto class is instantiated and used by
            the ZipEntry() class when encryption or decryption on an entry is employed.
            If for some reason you really wanted to use a weak encryption algorithm
            in some other application, you might use this library.  But you would be much
            better off using one of the built-in strong encryption libraries in the 
            .NET Framework, like the AES algorithm or SHA. 
            </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.#ctor">
      <summary>
             The default constructor for ZipCrypto.
             </summary>
      <remarks>
             This class is intended for internal use by the library only. It's probably not useful to you. Seriously.
             Stop reading this documentation.  It's a waste of your time.  Go do something else.
             Check the football scores. Go get an ice cream with a friend.  Seriously.
             </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.DecryptMessage(System.Byte[],System.Int32)">
      <summary> 
            Call this method on a cipher text to render the plaintext. You must
            first initialize the cipher with a call to InitCipher.
            </summary>
      <example>
        <code>
            var cipher = new ZipCrypto();
            cipher.InitCipher(Password);
            // Decrypt the header.  This has a side effect of "further initializing the
            // encryption keys" in the traditional zip encryption. 
            byte[] DecryptedMessage = cipher.DecryptMessage(EncryptedMessage);
            </code>
      </example>
      <param name="cipherText">The encrypted buffer.</param>
      <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to CipherText.Length.
            </param>
      <returns>The plaintext.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.EncryptMessage(System.Byte[],System.Int32)">
      <summary>
            This is the converse of DecryptMessage.  It encrypts the plaintext
            and produces a ciphertext. 
            </summary>
      <param name="plaintext">The plain text buffer.</param>
      <param name="length">
            The number of bytes to encrypt.  
            Should be less than or equal to PlainText.Length.
            </param>
      <returns>The ciphertext.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipCrypto.InitCipher(System.String)">
      <summary>
             This initializes the cipher with the given password. 
             See AppNote.txt for details. 
             </summary>
      <param name="passphrase">The passphrase for encrypting or decrypting with this cipher.
             </param>
      <remarks>
        <code>
             Step 1 - Initializing the encryption keys
             -----------------------------------------
             Start with these keys:        
             Key(0) := 305419896 (0x12345678)
             Key(1) := 591751049 (0x23456789)
             Key(2) := 878082192 (0x34567890)
             
             Then, initialize the keys with a password:
             
             loop for i from 0 to length(password)-1
                 update_keys(password(i))
             end loop
             
             Where update_keys() is defined as:
             
             update_keys(char):
               Key(0) := crc32(key(0),char)
               Key(1) := Key(1) + (Key(0) bitwiseAND 000000ffH)
               Key(1) := Key(1) * 134775813 + 1
               Key(2) := crc32(key(2),key(1) rightshift 24)
             end update_keys
             
             Where crc32(old_crc,char) is a routine that given a CRC value and a
             character, returns an updated CRC value after applying the CRC-32
             algorithm described elsewhere in this document.
            
             </code>
        <para>
             After the keys are initialized, then you can use the cipher to encrypt
             the plaintext. 
             </para>
        <para>
             Essentially we encrypt the password with the keys, then discard the 
             ciphertext for the password. This initializes the keys for later use.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipCrypto.MagicByte">
      <summary> 
            From AppNote.txt:
            unsigned char decrypt_byte()
                local unsigned short temp
                temp :=- Key(2) | 2
                decrypt_byte := (temp * (temp ^ 1)) bitshift-right 8
            end decrypt_byte
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipCipherStream">
      <summary>
            A Stream for reading and concurrently decrypting data from a zip file, 
            or for writing and concurrently encrypting data to a zip file.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipCipherStream.#ctor(System.IO.Stream,Ionic.Zip.ZipCrypto,Ionic.Zip.CryptoMode)">
      <summary>
            The  constructor.
            </summary>
      <param name="s">The underlying stream</param>
      <param name="mode">To either encrypt or decrypt.</param>
      <param name="cipher">The pre-initialized ZipCrypto object.</param>
    </member>
    <member name="T:Ionic.Zip.ZipEntry">
      <summary>
            This class models an entry in the directory contained within the zip file.
            The class is generally not used from within application code, though it is
            used by the ZipFile class.
            </summary>
      <summary>
            Represents a single entry in a ZipFile. Typically, applications
            get a ZipEntry by enumerating the entries within a ZipFile,
            or by adding an entry to a ZipFile.  
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ReadDirEntry(System.IO.Stream,System.Text.Encoding)">
      <summary>
            Reads one entry from the zip directory structure in the zip file. 
            </summary>
      <param name="s">the stream from which to read.</param>
      <param name="expectedEncoding">
            The text encoding to use if the entry is not marked UTF-8.
            </param>
      <returns>the entry read from the archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.IsNotValidZipDirEntrySig(System.Int32)">
      <summary>
            Returns true if the passed-in value is a valid signature for a ZipDirEntry. 
            </summary>
      <param name="signature">the candidate 4-byte signature value.</param>
      <returns>true, if the signature is valid according to the PKWare spec.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Read(Ionic.Zip.ZipFile,System.Boolean)">
      <summary>
            Reads one ZipEntry from the given stream.  If the entry is encrypted, we don't
            actually decrypt at this point. 
            </summary>
      <param name="zf">the zipfile this entry belongs to.</param>
      <param name="first">true of this is the first entry being read from the stream.</param>
      <returns>the ZipEntry read from the stream.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract">
      <summary>
             Extract the entry to the filesystem, starting at the current working directory. 
             </summary>
      <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you... If you don't like these, check out the 
             <c>ExtractWithPassword()</c> methods.
             </overloads>
      <seealso cref="P:Ionic.Zip.ZipEntry.OverwriteOnExtract" />
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.Boolean)" />
      <remarks>
        <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the Extract method that accepts a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
        <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.Boolean)">
      <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="overwrite">true if the caller wants to overwrite an existing file by the same name in the filesystem.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)">
      <summary>
            Extracts the entry to the specified stream. 
            </summary>
      <remarks>
        <para>
            For example, the caller could specify Console.Out, or a MemoryStream.
            </para>
      </remarks>
      <param name="stream">the stream to which the entry should be extracted.  </param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.String)">
      <summary>
            Extract the entry to the filesystem, starting at the specified base directory. 
            </summary>
      <param name="baseDirectory">the pathname of the base directory</param>
      <seealso cref="P:Ionic.Zip.ZipEntry.OverwriteOnExtract" />
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.String,System.Boolean)" />
      <seealso cref="M:Ionic.Zip.ZipFile.Extract(System.String)" />
      <example>
            This example extracts only the entries in a zip file that are .txt files, into a directory called "textfiles".
            <code lang="C#">
            using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
            {
              foreach (string s1 in zip.EntryFilenames)
              {
                if (s1.EndsWith(".txt")) 
                {
                  ZipEntry entry= zip[s1];
                  entry.Extract("textfiles");
                }
              }
            }
            </code><code lang="VB">
              Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                  Dim s1 As String
                  For Each s1 In zip.EntryFilenames
                      If s1.EndsWith(".txt") Then
                          Dim entry as ZipEntry
                          entry = zip(s1)
                          entry.Extract("textfiles")
                      End If
                  Next
              End Using
            </code></example>
      <remarks>
        <para>
            Existing entries in the filesystem will not be overwritten. If you would like to 
            force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
            or try one of the overloads of the Extract method that accept a boolean flag
            to indicate explicitly whether you want overwrite.
            </para>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.Extract(System.String,System.Boolean)">
      <summary>
            Extract the entry to the filesystem, starting at the specified base directory, 
            and potentially overwriting existing files in the filesystem. 
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String)">
      <summary>
             Extract the entry to the filesystem, using the current working directory
             and the specified password. 
             </summary>
      <overloads>
             This method has a bunch of overloads! One of them is sure to be
             the right one for you...
             </overloads>
      <seealso cref="P:Ionic.Zip.ZipEntry.OverwriteOnExtract" />
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)" />
      <remarks>
        <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly that you want overwrite.
             </para>
        <para>
             See the remarks on the <see cref="P:Ionic.Zip.ZipEntry.LastModified" /> property for some details 
             about how the "last modified" time of the created file is set.
             </para>
      </remarks>
      <example>
             In this example, entries that use encryption are extracted using a particular password.
             <code lang="VB">
             Using zip As new ZipFile(FilePath)
                 Dim e As ZipEntry
                 For Each e In zip
                     If (e.UsesEncryption)
                       e.ExtractWithPassword("Secret!")
                     Else
                       e.Extract
                     End If 
                 Next
             End Using
             </code></example>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory,
             and using the specified password. 
             </summary>
      <seealso cref="P:Ionic.Zip.ZipEntry.OverwriteOnExtract" />
      <seealso cref="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)" />
      <remarks>
        <para>
             Existing entries in the filesystem will not be overwritten. If you would like to 
             force the overwrite of existing files, see the <c>OverwriteOnExtract</c> property, 
             or try one of the overloads of the ExtractWithPassword method that accept a boolean flag
             to indicate explicitly whether you want overwrite.
             </para>
        <para>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </para>
      </remarks>
      <param name="baseDirectory">The pathname of the base directory.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.Boolean,System.String)">
      <summary>
            Extract the entry to a file in the filesystem, potentially overwriting
            any existing file.
            </summary>
      <remarks>
        <para>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </para>
      </remarks>
      <param name="overwrite">true if the caller wants to overwrite an existing 
            file by the same name in the filesystem.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.String,System.Boolean,System.String)">
      <summary>
             Extract the entry to the filesystem, starting at the specified base directory, 
             and potentially overwriting existing files in the filesystem. 
             </summary>
      <remarks>
             See the remarks on the LastModified property, for some details 
             about how the last modified time of the created file is set.
             </remarks>
      <param name="baseDirectory">the pathname of the base directory</param>
      <param name="overwrite">If true, overwrite any existing files if necessary upon extraction.</param>
      <param name="password">The Password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.ExtractWithPassword(System.IO.Stream,System.String)">
      <summary>
            Extracts the entry to the specified stream, using the specified Password.
            For example, the caller could extract to Console.Out, or to a MemoryStream.
            </summary>
      <remarks>
            See the remarks on the LastModified property, for some details 
            about how the last modified time of the created file is set.
            </remarks>
      <param name="stream">the stream to which the entry should be extracted.  </param>
      <param name="password">The password to use for decrypting the entry.</param>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.OpenReader">
      <summary>
            Opens the backing stream for the zip entry in the archive, for reading. 
            </summary>
      <remarks>
        <para>
            The ZipEntry has methods that extract the entry to an already-opened stream.
            This is an alternative method for those applications that wish to manipulate the stream directly.
            </para>
        <para>
            The <see cref="T:Ionic.Zip.CrcCalculatorStream" /> that is returned is just a regular read-only stream - you can use it as you would
            any stream.  The one additional feature it adds is that it calculates a CRC32 on the bytes of the stream 
            as it is read.  This CRC should be used by the application to validate the content of the ZipEntry, when 
            the read is complete.  You don't have to validate the CRC, but you should. Check the example for how to do this. 
            </para>
        <para>
            If the entry is protected with a password, then you need to set the password on the entry prior to calling 
            <see cref="M:Ionic.Zip.ZipEntry.OpenReader" />.
            </para>
      </remarks>
      <example>
            In this example, we open a zipfile, then read in a named entry via a stream, scanning
            the bytes in the entry as we go.  Finally, the CRC and the size of the entry are verified.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToRead))
            {
              ZipEntry e1= zip["Download.mp3"];
              using (CrcCalculatorStream s = e1.OpenReader())
              {
                byte[] buffer = new byte[4096];
                int n, totalBytesRead= 0;
                do {
                  n = s.Read(buffer,0, buffer.Length);
                  totalBytesRead+=n; 
                } while (n&gt;0);
                 if (s.Crc32 != e1.Crc32)
                  throw new Exception(string.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32));
                 if (totalBytesRead != e1.UncompressedSize)
                  throw new Exception(string.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize));
              }
            }
            </code><code lang="VB">
              Using zip As New ZipFile(ZipFileToRead)
                  Dim e1 As ZipEntry = zip.Item("Download.mp3")
                  Using s As CrcCalculatorStream = e1.OpenReader
                      Dim n As Integer
                      Dim buffer As Byte() = New Byte(4096) {}
                      Dim totalBytesRead As Integer = 0
                      Do
                          n = s.Read(buffer, 0, buffer.Length)
                          totalBytesRead = (totalBytesRead + n)
                      Loop While (n &gt; 0)
                      If (s.Crc32 &lt;&gt; e1.Crc32) Then
                          Throw New Exception(String.Format("The Zip Entry failed the CRC Check. (0x{0:X8}!=0x{1:X8})", s.Crc32, e1.Crc32))
                      End If
                      If (totalBytesRead &lt;&gt; e1.UncompressedSize) Then
                          Throw New Exception(String.Format("We read an unexpected number of bytes. ({0}!={1})", totalBytesRead, e1.UncompressedSize))
                      End If
                  End Using
              End Using
            </code></example>
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.IO.Stream)" />
      <returns>The Stream for reading.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipEntry.OpenReader(System.String)">
      <summary>
            Opens the backing stream for an encrypted zip entry in the archive, for reading. 
            </summary>
      <remarks>
        <para>
            See the documentation on the OpenReader() method for full details.  This overload allows the 
            application to specify a password for the ZipEntry to be read. 
            </para>
      </remarks>
      <param name="password">The password to use for decrypting the entry.</param>
      <returns>The Stream for reading.</returns>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.AttributesIndicateDirectory">
      <summary>
            True if the referenced entry is a directory.  
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.LastModified">
      <summary>
             The time and date at which the file indicated by the ZipEntry was last modified. 
             </summary>
      <remarks>
        <para>
             The DotNetZip library sets the LastModified value for an entry, equal to the 
             Last Modified time of the file in the filesystem.  If an entry is added from a stream, 
             in which case no Last Modified attribute is available, the library uses 
             <c>System.DateTime.Now</c> for this value, for the given entry. 
             </para>
        <para>
             It is also possible to set the LastModified value on an entry, to an arbitrary
             value.  Be aware that because of the way the PKZip specification describes how
             times are stored in the zip file, the full precision of the
             <c>System.DateTime</c> datatype is not stored in LastModified when saving zip
             files.  For more information on how times are formatted, see the PKZip
             specification.
             </para>
        <para>
             The last modified time of the file created upon a call to <c>ZipEntry.Extract()</c> 
             may be adjusted during extraction to compensate
             for differences in how the .NET Base Class Library deals
             with daylight saving time (DST) versus how the Windows
             filesystem deals with daylight saving time. 
             See http://blogs.msdn.com/oldnewthing/archive/2003/10/24/55413.aspx for more context.
             </para>
        <para>
             In a nutshell: Daylight savings time rules change regularly.  In
             2007, for example, the inception week of DST changed.  In 1977,
             DST was in place all year round. In 1945, likewise.  And so on.
             Win32 does not attempt to guess which time zone rules were in
             effect at the time in question.  It will render a time as
             "standard time" and allow the app to change to DST as necessary.
              .NET makes a different choice.
             </para>
        <para>
             Compare the output of FileInfo.LastWriteTime.ToString("f") with
             what you see in the Windows Explorer property sheet for a file that was last
             written to on the other side of the DST transition. For example,
             suppose the file was last modified on October 17, 2003, during DST but
             DST is not currently in effect. Explorer's file properties
             reports Thursday, October 17, 2003, 8:45:38 AM, but .NETs
             FileInfo reports Thursday, October 17, 2003, 9:45 AM.
             </para>
        <para>
             Win32 says, "Thursday, October 17, 2002 8:45:38 AM PST". Note:
             Pacific STANDARD Time. Even though October 17 of that year
             occurred during Pacific Daylight Time, Win32 displays the time as
             standard time because that's what time it is NOW.
             </para>
        <para>
             .NET BCL assumes that the current DST rules were in place at the
             time in question.  So, .NET says, "Well, if the rules in effect
             now were also in effect on October 17, 2003, then that would be
             daylight time" so it displays "Thursday, October 17, 2003, 9:45
             AM PDT" - daylight time.
             </para>
        <para>
             So .NET gives a value which is more intuitively correct, but is
             also potentially incorrect, and which is not invertible. Win32
             gives a value which is intuitively incorrect, but is strictly
             correct.
             </para>
        <para>
             Because of this funkiness, this library adds one hour to the LastModified time
             on the extracted file, if necessary.  That is to say, if the time in question
             had occurred in what the .NET Base Class Library assumed to be DST (an
             assumption that may be wrong given the constantly changing DST rules).
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ForceNoCompression">
      <summary>
             When this is set, the entry is not compressed when written to 
             the archive.  For example, the application might want to set flag to <c>true</c>
             this when zipping up JPG or MP3 files, which are already compressed.
             </summary>
      <seealso cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.LocalFileName">
      <summary>
            The name of the filesystem file, referred to by the ZipEntry. 
            </summary>
      <remarks>
        <para>
            This may be different than the path used in the archive itself. What I mean is, 
            if you call <c>Zip.AddFile("fooo.txt", AlternativeDirectory)</c>, then the 
            path used for the ZipEntry within the zip archive will be different than this path.  
            This path is used to locate the thing-to-be-zipped on disk. 
            </para>
        <para>
            If the entry is being added from a stream, then this is null (Nothing in VB).
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.FileName" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.FileName">
      <summary>
             The name of the file contained in the ZipEntry. 
             </summary>
      <remarks>
        <para>
             When writing a zip, this path has backslashes replaced with 
             forward slashes, according to the zip spec, for compatibility
             with Unix(tm) and ... get this.... Amiga!
             </para>
        <para>
             This is the name of the entry in the ZipFile itself.  This name may be different
             than the name of the filesystem file used to create the entry (LocalFileName). In fact, there
             may be no filesystem file at all, if the entry is created from a stream or a string.
             </para>
        <para>
             When setting this property, the value is made permanent only after a call to one of the ZipFile.Save() methods 
             on the ZipFile that contains the ZipEntry. By reading in a ZipFile, then explicitly setting the FileName on an
             entry contained within the ZipFile, and then calling Save(), you will effectively rename the entry within 
             the zip archive.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.LocalFileName" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.VersionNeeded">
      <summary>
            The version of the zip engine needed to read the ZipEntry.  
            </summary>
      <remarks>
            This is usually 0x14. 
            (Decimal 20). If ZIP64 is in use, the version will be decimal 45.  
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Comment">
      <summary>
             The comment attached to the ZipEntry. 
             </summary>
      <remarks>
             By default, the Comment is encoded in IBM437 code page. You can specify 
             an alternative with <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /></remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.BitField">
      <summary>
             The bitfield as defined in the zip spec. You probably never need to look at this.
             </summary>
      <remarks>
        <code>
             bit  0 - set if encryption is used.
             b. 1-2 - set to determine whether normal, max, fast deflation.  
                      This library always leaves these bits unset when writing (indicating 
                      "normal" deflation").
            
             bit  3 - indicates crc32, compressed and uncompressed sizes are zero in
                      local header.  We always leave this as zero on writing, but can read
                      a zip with it nonzero. 
            
             bit  4 - reserved for "enhanced deflating". This library doesn't do enhanced deflating.
             bit  5 - set to indicate the zip is compressed patched data.  This library doesn't do that.
             bit  6 - set if strong encryption is used (must also set bit 1 if bit 6 is set)
             bit  7 - unused
             bit  8 - unused
             bit  9 - unused
             bit 10 - unused
             Bit 11 - Language encoding flag (EFS).  If this bit is set,
                      the filename and comment fields for this file
                      must be encoded using UTF-8. This library currently does not support UTF-8.
             Bit 12 - Reserved by PKWARE for enhanced compression.
             Bit 13 - Used when encrypting the Central Directory to indicate 
                      selected data values in the Local Header are masked to
                      hide their actual values.  See the section describing 
                      the Strong Encryption Specification for details.
             Bit 14 - Reserved by PKWARE.
             Bit 15 - Reserved by PKWARE.
             </code>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressionMethod">
      <summary>
            The compression method employed for this ZipEntry. 0x08 = Deflate.  0x00 =
            Store (no compression).  Really, this should be an enum.  But the zip spec
            makes it a byte. So here it is. 
            </summary>
      <remarks>
        <para>When reading an entry from an existing zipfile, the value you retrieve here
            indicates the compression method used on the entry by the original creator of the zip.  
            When writing a zipfile, you can specify either 0x08 (Deflate) or 0x00 (None).  If you 
            try setting something else, it will throw an exception.  
            </para>
        <para>
            You may wish to set CompressionMethod to 0 (None) when zipping previously compressed
            data like jpg, png, or mp3 files.  This can save time and cpu cycles.
            </para>
      </remarks>
      <example>
            In this example, the first entry added to the zip archive uses 
            the default behavior - compression is used where it makes sense.  
            The second entry, the MP3 file, is added to the archive without being compressed.
            <code>
            using (ZipFile zip = new ZipFile(ZipFileToCreate))
            {
              ZipEntry e1= zip.AddFile(@"c:\temp\Readme.txt");
              ZipEntry e2= zip.AddFile(@"c:\temp\StopThisTrain.mp3");
              e2.CompressionMethod = 0;
              zip.Save();
            }
            </code><code lang="VB">
            Using zip as new ZipFile(ZipFileToCreate)
              zip.AddFile("c:\temp\Readme.txt")
              Dim e2 as ZipEntry = zip.AddFile("c:\temp\StopThisTrain.mp3")
              e2.CompressionMethod = 0
              zip.Save
            End Using
            </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressedSize">
      <summary>
            The compressed size of the file, in bytes, within the zip archive. 
            </summary>
      <remarks>
            The compressed size is computed during compression. This means that it is only
            valid to read this AFTER reading in an existing zip file, or AFTER saving a
            zipfile you are creating.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UncompressedSize">
      <summary>
            The size of the file, in bytes, before compression, or after extraction. 
            </summary>
      <remarks>
            This property is valid AFTER reading in an existing zip file, or AFTER saving the 
            ZipFile that contains the ZipEntry.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.CompressionRatio">
      <summary>
             The ratio of compressed size to uncompressed size of the ZipEntry.
             </summary>
      <remarks>
        <para>
             This is a ratio of the compressed size to the uncompressed size of the entry,
             expressed as a double in the range of 0 to 100+. A value of 100 indicates no
             compression at all.  It could be higher than 100 when the compression algorithm
             actually inflates the data.
             </para>
        <para>
             You could format it for presentation to a user via a format string of "{3,5:F0}%"
             to see it as a percentage. 
             </para>
        <para>
             If the size of the original uncompressed file is 0, (indicating a denominator of 0)
             the return value will be zero. 
             </para>
        <para>
             This property is valid AFTER reading in an existing zip file, or AFTER saving the 
             ZipFile that contains the ZipEntry.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Crc32">
      <summary>
            The CRC (Cyclic Redundancy Check) on the contents of the ZipEntry. 
            </summary>
      <remarks>
            You probably don't need to concern yourself with this. The CRC is generated according
            to the algorithm described in the Pkzip specification. It is a read-only property;
            when creating a Zip archive, the CRC for each entry is set only after a call to
            Save() on the containing ZipFile.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.IsDirectory">
      <summary>
            True if the entry is a directory (not a file). 
            This is a readonly property on the entry.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UsesEncryption">
      <summary>
            A derived property that is <c>true</c> if the entry uses encryption.  
            </summary>
      <remarks>
            This is a readonly property on the entry.
            Upon reading an entry, this bool is determined by
            the data read.  When writing an entry, this bool is
            determined by whether the Encryption property is set to something other than
            EncryptionAlgorithm.None. 
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Encryption">
      <summary>
             Set this to specify which encryption algorithm to use for the entry.
             </summary>
      <remarks>
        <para>
             When setting this property, you must also set a Password on the entry.  The set of
             algorithms supported is determined by the authors of this library.  The PKZIP
             specification from PKWare defines a set of encryption algorithms, and the data formats
             for the zip archive that support them. Other vendors of tools and libraries, such as
             WinZip or Xceed, also specify and support different encryption algorithms and data
             formats.
             </para>
        <para>
             There is no common, ubiquitous multi-vendor standard for strong encryption. There is
             broad support for "traditional" Zip encryption, sometimes called Zip 2.0 encryption,
             as specified by PKWare, but this encryption is considered weak. This library currently
             supports AES 128 and 256 in addition to the Zip 2.0 "weak" encryption.
             </para>
        <para>
             The WinZip AES encryption algorithms are not supported on the .NET Compact Framework. 
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.Password">
      <summary>
             Set this to request that the entry be encrypted when writing the zip
             archive, ot to specify the password to be used when extracting an 
             existing archive.
             </summary>
      <remarks>
        <para>
             This is a write-only property on the entry. The password set here is implicitly 
             used to encrypt the entry during the Save() operation, or to decrypt during
             the <see cref="M:Ionic.Zip.ZipEntry.Extract" /> or <see cref="M:Ionic.Zip.ZipEntry.OpenReader" /> operation. 
             </para>
        <para>
             If you have read a zipfile, setting the password on an entry and then
             saving the zipfile does not update the password on that entry in the
             archive.  If you read a zipfile that contains encrypted entries, you cannot
             modify the password on any entry, except by extracting the entry with the
             first password (if any), and then adding a new entry with a new password.
             If you do this, you may wish to also remove the previous entry.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.OverwriteOnExtract">
      <summary>
            Specifies that the extraction should overwrite any existing files.
            </summary>
      <remarks>
            This applies only when calling an Extract method. By default this 
            property is false. Generally you will get overwrite behavior by calling 
            one of the overloads of the Extract() method that accepts a boolean flag
            to indicate explicitly whether you want overwrite.
            </remarks>
      <seealso cref="M:Ionic.Zip.ZipEntry.Extract(System.Boolean)" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.WillReadTwiceOnInflation">
      <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm in DeflateStream can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
        <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
        <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
        <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream.  As with other
             properties (like Password and ForceNoCompression), setting the corresponding
             delegate on the ZipFile class itself will set it on all ZipEntry items that are
             subsequently added to the ZipFile instance.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" />
      <seealso cref="T:Ionic.Zip.ReReadApprovalCallback" />
    </member>
    <member name="P:Ionic.Zip.ZipEntry.WantCompression">
      <summary>
             A callback that allows the application to specify whether compression should
             be used for a given entry that is about to be added to the zip archive.
             </summary>
      <remarks>
             See <see cref="P:Ionic.Zip.ZipFile.WantCompression" /></remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.UseUnicodeAsNecessary">
      <summary>
            Set to indicate whether to use UTF-8 encoding on filenames and 
            comments, according to the PKWare specification.  
            </summary>
      <remarks>
            If this flag is set, the entry will be marked as encoded with UTF-8, 
            according to the PWare spec, if necessary.  Necessary means, if the filename or 
            entry comment (if any) cannot be reflexively encoded with the default (IBM437) code page. 
            </remarks>
      <remarks>
            Setting this flag to true is equivalent to setting <see cref="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding" /> to <c>System.Text.Encoding.UTF8</c></remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ProvisionalAlternateEncoding">
      <summary>
             The text encoding to use for this ZipEntry, when the default
             encoding is insufficient.
             </summary>
      <remarks>
        <para>
             According to the zip specification from PKWare, filenames and comments for a
             ZipEntry are encoded either with IBM437 or with UTF8.  But, some archivers do not
             follow the specification, and instead encode characters using the system default
             code page, or an arbitrary code page.  For example, WinRAR when run on a machine in
             Shanghai may encode filenames with the Chinese (Big-5) code page.  This behavior is
             contrary to the Zip specification, but it occurs anyway.  This property exists to
             support that non-compliant behavior when reading or writing zip files.
             </para>
        <para>
             When writing zip archives that will be read by one of these other archivers, use this property to 
             specify the code page to use when encoding filenames and comments into the zip
             file, when the IBM437 code page will not suffice.
             </para>
        <para>
             Be aware that a zip file created after you've explicitly specified the code page will not 
             be compliant to the PKWare specification, and may not be readable by compliant archivers. 
             On the other hand, many archivers are non-compliant and can read zip files created in 
             arbitrary code pages. 
             </para>
        <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no standard way for the 
             creator (DotNetZip) to specify in the zip file which code page has been used. DotNetZip is not
             able to inspect the zip file and determine the codepage used for the entries within it. Therefore, 
             you, the application author, must determine that.  If you use a codepage which results in filenames
             that are not legal in Windows, you will get exceptions upon extract. Caveat Emptor.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipEntry.ActualEncoding">
      <summary>
            The text encoding actually used for this ZipEntry.
            </summary>
    </member>
    <member name="T:Ionic.Zip.EncryptionAlgorithm">
      <summary>
            An enum that provides the various encryption algorithms supported by this library.
            </summary>
      <remarks>
        <para>
            PkzipWeak implies the use of Zip 2.0 encryption, which is known to be weak and subvertible. 
            </para>
        <para>
            A note on interoperability: Values of PkzipWeak and None are specified in the PKWare AppNote.txt document, are 
            considered to be "standard".  Zip archives produced using these options will be interoperable with many other
            zip tools and libraries, including Windows Explorer.
            </para>
        <para>
            Values of WinZipAes128 and WinZipAes256 are not part of the Zip specification, but rather imply the use of a 
            vendor-specific extension from WinZip. If you want to produce interoperable Zip archives, do not use these values. 
            For example, if you
            produce a zip archive using WinZipAes256, you will be able to open it in Windows Explorer on Windows XP and Vista, 
            but you will not be able to extract entries; trying this will lead to an "unspecified error". For this reason, 
            some people have said that a zip archive that uses WinZip's AES encryption is not actually a zip archive at all.
            A zip archive produced this way will be readable with the WinZip tool
            (Version 11 and beyond).
            </para>
        <para>
            There are other third-party tools and libraries, both commercial and otherwise, that support WinZip's 
            AES encryption. These will be able to read AES-encrypted zip archives produced by DotNetZip, and conversely applications 
            that use DotNetZip to read zip archives will be able to read AES-encrypted archives produced by those tools
            or libraries.  Consult the documentation for those other tools and libraries to find out if WinZip's AES 
            encryption is supported. 
            </para>
        <para>
            In case you care: According to the WinZip specification, the actual key used is derived from the 
            <see cref="P:Ionic.Zip.ZipEntry.Password" /> via an algorithm that complies with RFC 2898, using an iteration count of 1000.
            I am no security expert, but I think you should use a long-ish password if you employ 256-bit AES
            encryption.  Make it 16 characters or more.  
            </para>
        <para>
            The WinZip AES algorithms are not supported with the version of DotNetZip that runs on the .NET Compact Framework. 
            This is because .NET CF lacks the HMACSHA1 class that is required for producing the archive.
            </para>
      </remarks>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.None">
      <summary>
            No encryption at all.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.PkzipWeak">
      <summary>
            Traditional or Classic pkzip encryption.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes128">
      <summary>
            WinZip AES encryption (128 key bits).
            </summary>
    </member>
    <member name="F:Ionic.Zip.EncryptionAlgorithm.WinZipAes256">
      <summary>
            WinZip AES encryption (256 key bits).
            </summary>
    </member>
    <member name="T:Ionic.Zip.EntrySource">
      <summary>
            An enum that specifies the source of the ZipEntry. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.EntrySource.None">
      <summary>
            Default value.  Invalid on a bonafide ZipEntry.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EntrySource.Filesystem">
      <summary>
            Entry was instantiated by Adding an entry from the filesystem.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EntrySource.Zipfile">
      <summary>
            Entry was instantiated by reading a zipfile.
            </summary>
    </member>
    <member name="F:Ionic.Zip.EntrySource.Stream">
      <summary>
            Entry was instantiated via a stream or string.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ReReadApprovalCallback">
      <summary>
            Delegate for the callback by which the application gives approval for multiple
            reads of the file stream. This callback is called only when the initial 
            compression operation inflates the size of the file data. 
            </summary>
    </member>
    <member name="T:Ionic.Zip.WantCompressionCallback">
      <summary>
            Delegate for the callback by which the application tells the libraary whether
            to use compression on the file or not.  
            </summary>
      <remarks>
        <para>
            Using this callback, the application can 
            specify that previously-compressed files (.mp3, .png, .docx, etc) should 
            not be compressed, for example, or can turn on or off compression based on any 
            other factor.
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
    </member>
    <member name="T:Ionic.Zip.ZipProgressEventType">
      <summary>
            In an EventArgs type, indicates which sort of progress event is being reported.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Started">
      <summary>
            Indicates that a Read() operation has started.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_BeforeReadEntry">
      <summary>
            Indicates that an individual entry in the archive is about to be read.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_AfterReadEntry">
      <summary>
            Indicates that an individual entry in the archive has just been read.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_Completed">
      <summary>
            Indicates that a Read() operation has completed.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Reading_ArchiveBytesRead">
      <summary>
            The given event reports the number of bytes read so far
            during a Read() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Started">
      <summary>
            Indicates that a Save() operation has started.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeWriteEntry">
      <summary>
            Indicates that an individual entry in the archive is about to be written.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterWriteEntry">
      <summary>
            Indicates that an individual entry in the archive has just been saved.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_Completed">
      <summary>
            Indicates that a Save() operation has completed.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterSaveTempArchive">
      <summary>
            Indicates that the zip archive has been created in a
            temporary location during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_BeforeRenameTempArchive">
      <summary>
            Indicates that the temporary file is about to be renamed to the final archive 
            name during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterRenameTempArchive">
      <summary>
            Indicates that the temporary file is has just been renamed to the final archive 
            name during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_AfterCompileSelfExtractor">
      <summary>
            Indicates that the self-extracting archive has been compiled
            during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Saving_EntryBytesRead">
      <summary>
            The given event is reporting the number of source bytes that have run through the compressor so far
            during a Save() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractEntry">
      <summary>
            Indicates that an entry is about to be extracted. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractEntry">
      <summary>
            Indicates that an entry has just been extracted. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_EntryBytesWritten">
      <summary>
            The given event is reporting the number of bytes written so far for the current entry
            during an Extract() operation.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_BeforeExtractAll">
      <summary>
            Indicates that an ExtractAll operation is about to begin.
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipProgressEventType.Extracting_AfterExtractAll">
      <summary>
            Indicates that an ExtractAll operation has completed.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipProgressEventArgs">
      <summary>
            Provides information about the progress of a save, read, or extract operation. 
            This is a base class; you will probably use one of the classes derived from this one.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.EntriesTotal">
      <summary>
            The total number of entries to be saved or extracted.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.CurrentEntry">
      <summary>
            The name of the last entry saved or extracted.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.Cancel">
      <summary>
            In an event handler, set this to cancel the save or extract 
            operation that is in progress.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.EventType">
      <summary>
            The type of event being reported.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.ArchiveName">
      <summary>
            Returns the archive name associated to this event.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.BytesTransferred">
      <summary>
            The number of bytes read or written so far for this entry.  
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipProgressEventArgs.TotalBytesToTransfer">
      <summary>
            Total number of bytes that will be read or written for this entry.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ReadProgressEventArgs">
      <summary>
            Provides information about the progress of a Read operation.
            </summary>
    </member>
    <member name="T:Ionic.Zip.SaveProgressEventArgs">
      <summary>
            Provides information about the progress of a save operation.
            </summary>
    </member>
    <member name="M:Ionic.Zip.SaveProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry)">
      <summary>
            Constructor for the SaveProgressEventArgs.
            </summary>
      <param name="archiveName">the name of the zip archive.</param>
      <param name="before">whether this is before saving the entry, or after</param>
      <param name="entriesTotal">The total number of entries in the zip archive.</param>
      <param name="entriesSaved">Number of entries that have been saved.</param>
      <param name="entry">The entry involved in the event.</param>
    </member>
    <member name="P:Ionic.Zip.SaveProgressEventArgs.EntriesSaved">
      <summary>
            Number of entries saved so far.
            </summary>
    </member>
    <member name="T:Ionic.Zip.ExtractProgressEventArgs">
      <summary>
            Provides information about the progress of the extract operation.
            </summary>
    </member>
    <member name="M:Ionic.Zip.ExtractProgressEventArgs.#ctor(System.String,System.Boolean,System.Int32,System.Int32,Ionic.Zip.ZipEntry,System.String,System.Boolean)">
      <summary>
            Constructor for the ExtractProgressEventArgs.
            </summary>
      <param name="archiveName">the name of the zip archive.</param>
      <param name="before">whether this is before saving the entry, or after</param>
      <param name="entriesTotal">The total number of entries in the zip archive.</param>
      <param name="entriesExtracted">Number of entries that have been extracted.</param>
      <param name="entry">The entry involved in the event.</param>
      <param name="extractLocation">The location to which entries are extracted.</param>
      <param name="wantOverwrite">indicates whether the extract operation will overwrite existing files.</param>
    </member>
    <member name="P:Ionic.Zip.ExtractProgressEventArgs.EntriesExtracted">
      <summary>
            Number of entries extracted so far.  This is set only if the 
            EventType is Extracting_BeforeExtractEntry or Extracting_AfterExtractEntry, and 
            the Extract() is occurring witin the scope of a call to ExtractAll().
            </summary>
    </member>
    <member name="P:Ionic.Zip.ExtractProgressEventArgs.Overwrite">
      <summary>
            True if the extract operation overwrites existing files.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ExtractProgressEventArgs.ExtractLocation">
      <summary>
            Returns the extraction target location, a filesystem path. 
            </summary>
    </member>
    <member name="T:Ionic.Zip.ZipFile">
      <summary>
            The ZipFile type represents a zip archive file.  This is the main type in the 
            DotNetZip class library.  This class reads and writes zip files, as defined in the format
            for zip described by PKWare.  The compression for this implementation was, at one time, based on the
            System.IO.Compression.DeflateStream base class in the .NET Framework
            base class library, available in v2.0 and later of the .NET Framework. As of v1.7 of DotNetZip,
            the compression is provided by a managed-code version of Zlib, included with DotNetZip. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.ZipFile.DefaultEncoding">
      <summary>
            The default text encoding used in zip archives.  It is numeric 437, also known as IBM437. 
            </summary>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename. 
             The ZipFileName may be fully qualified.
             </summary>
      <remarks>
        <para>
             Applications can use this constructor to create a new ZipFile for writing, 
             or to slurp in an existing zip archive for read and write purposes.  
             </para>
        <para>
             To create a new zip archive, an application should call this constructor,
             passing the name of a file that does not exist.  Then the application can
             add directories or files to the ZipFile via <c>AddDirectory()</c>,
             <c>AddFile()</c>, <c>AddItem()</c> and then write the zip archive to the
             disk by calling <c>Save()</c>. The zip file is not actually written to
             the disk until the application calls <c>ZipFile.Save()</c>.  At that point
             the new zip file with the given name is created. 
             </para>
        <para>
             To read an existing zip archive, the application should call this constructor,
             passing the name of a valid zip file that does exist.  The file is then read into
             the <c>ZipFile</c> instance.  The app can then enumerate the entries or can modify
             the zip file, for example adding entries, removing entries, changing comments, and
             so on.  When reading an existing zip archive, the application may wish to
             explicitly specify that it is reading an existing zip file by using
             <c>ZipFile.Read()</c>.  On the other hand, this parameterized constructor allows
             applications to use the same code to add items to a zip archive, regardless of
             whether the zip file exists.
             </para>
        <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
        <para>
             By the way, if you are using multiple threads with DotNetZip, you really should
             donate $5 or $10 to the cause.  See http://cheeso.members.winisp.net/DotNetZipDonate.aspx.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <example>
             This example shows how to create a zipfile, and add a few files into it. 
             <code>
             using (ZipFile zip = new ZipFile(args[0]))
             { 
               // Store all files found in the top level directory, into the zip archive.
               String[] filenames = System.IO.Directory.GetFiles(args[1]);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code><code lang="VB">
             Dim ZipToCreate As String = "ex1.zip"
             Dim DirectoryToZip As String = "c:\temp"
             Using zip As ZipFile = New ZipFile(ZipToCreate)
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code></example>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.Text.Encoding)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, and 
             the specified Encoding.
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument</see> for basic information on all the ZipFile constructors.
             </para>
        <para>
             The Encoding is used as the default alternate encoding for entries with filenames
             or comments that cannot be encoded with the IBM437 code page.  This is a equivalent to setting 
             the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the ZIpFile instance after construction.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="encoding">The Encoding is used as the default alternate encoding for entries with filenames
             or comments that cannot be encoded with the IBM437 code page. </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor">
      <summary>
             Create a zip file, without specifying a target filename or stream to save to. 
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument</see> for basic information on all the ZipFile constructors.
             </para>
        <para>
             After instantiating with this constructor and adding entries to the archive,
             your application should call <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> or <see cref="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)" /> to save to a file or a stream, respectively. 
             If you call the no-argument <see cref="M:Ionic.Zip.ZipFile.Save" /> method, the Save() will throw, as there is no 
             known place to save the file. 
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
      </remarks>
      <example>
             This example creates a Zip archive called Backup.zip, containing all the files
             in the directory DirectoryToZip. Files within subdirectories are not zipped up.
             <code>
             using (ZipFile zip = new ZipFile())
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save("Backup.zip");
             }
             </code><code lang="VB">
             Using zip As New ZipFile
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save("Backup.zip")
             End Using
             </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.Text.Encoding)">
      <summary>
             Create a zip file, specifying a text Encoding, but without specifying a target filename or stream to save to. 
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument</see> for basic information on all the ZipFile constructors.
             </para>
      </remarks>
      <param name="encoding">The Encoding is used as the default alternate encoding for entries with filenames
             or comments that cannot be encoded with the IBM437 code page. </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, 
             and the specified status message writer. 
             </summary>
      <remarks>
        <para>
             See the documentation on the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument</see> for basic information on all the ZipFile constructors.
             </para>
        <para>
             This version of the constructor allows the caller to pass in a TextWriter, to which
             verbose messages will be written during extraction or creation of the zip archive.
             A console application may wish to pass System.Console.Out to get messages on the
             Console. A graphical or headless application may wish to capture the messages in a
             different <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display
             the messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
        <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <example>
        <code>
             using (ZipFile zip = new ZipFile("Backup.zip", System.Console.Out))
             { 
               // Store all files found in the top level directory, into the zip archive.
               // note: this code does not recurse subdirectories!
               String[] filenames = System.IO.Directory.GetFiles(DirectoryToZip);
               foreach (String filename in filenames)
               {
                 Console.WriteLine("Adding {0}...", filename);
                 zip.AddFile(filename);
               }  
               zip.Save();
             }
             </code>
        <code lang="VB">
             Using zip As New ZipFile("Backup.zip", System.Console.Out)
                 ' Store all files found in the top level directory, into the zip archive.
                 ' note: this code does not recurse subdirectories!
                 Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)
                 Dim filename As String
                 For Each filename In filenames
                     Console.WriteLine("Adding {0}...", filename)
                     zip.AddFile(filename)
                 Next
                 zip.Save
             End Using
             </code>
      </example>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="statusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.#ctor(System.String,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Creates a new ZipFile instance, using the specified ZipFileName for the filename, 
             the specified status message writer, and the specified Encoding.
             </summary>
      <remarks>
        <para>
             This constructor works like the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)">ZipFile constructor
             that accepts a single string argument.</see> See that reference for detail on what
             this constructor does.
             </para>
        <para>
             This version of the constructor allows the caller to pass in a TextWriter, and an
             Encoding.  The TextWriter will collect verbose messages that are generated by the
             library during extraction or creation of the zip archive.  A console application
             may wish to pass System.Console.Out to get messages on the Console. A graphical or
             headless application may wish to capture the messages in a different
             <c>TextWriter</c>, for example, a <c>StringWriter</c>, and then display the
             messages in a TextBox, or generate an audit log of ZipFile operations.
             </para>
        <para>
             The Encoding is used as the default alternate encoding for entries with filenames
             or comments that cannot be encoded with the IBM437 code page.  This is a equivalent to setting 
             the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property on the ZipFile instance after construction.
             </para>
        <para>
             To encrypt the data for the  files added to the ZipFile instance, set the Password
             property after creating the ZipFile instance.
             </para>
        <para>
             Instances of the ZipFile class are not multi-thread safe.  You may not party on a single
             instance with multiple threads.  You may have multiple threads that each use a distinct ZipFile 
             instance, or you can synchronize multi-thread access to a single instance.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipFileName refers to an existing file that is not a valid zip file. 
             </exception>
      <param name="zipFileName">The filename to use for the new zip archive.</param>
      <param name="statusMessageWriter">A TextWriter to use for writing verbose status messages.</param>
      <param name="encoding">The Encoding is used as the default alternate encoding for entries with filenames
             or comments that cannot be encoded with the IBM437 code page. </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddItem(System.String)">
      <summary>
             Adds an item, either a file or a directory, to a zip file archive.  
             </summary>
      <remarks>
        <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
        <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             The directory name used for the file within the archive is the same as
             the directory name (potentially a relative path) specified in the FileOrDirectoryName.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <overloads>This method has two overloads.</overloads>
      <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)">
      <summary>
             Adds an item, either a file or a directory, to a zip file archive, 
             explicitly specifying the directory path to be used in the archive. 
             </summary>
      <remarks>
        <para>
             If adding a directory, the add is recursive on all files and subdirectories 
             contained within it. 
             </para>
        <para>
             The name of the item may be a relative path or a fully-qualified path.
             The item added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive, which would override the 
             "natural" path of the filesystem file.
             </para>
        <para>
             Encryption will be used on the file data if the Password
             has been set on the ZipFile object, prior to calling this method.
             </para>
      </remarks>
      <exception cref="T:System.IO.FileNotFoundException">
             Thrown if the file or directory passed in does not exist. 
             </exception>
      <param name="fileOrDirectoryName">the name of the file or directory to add.</param>
      <param name="directoryPathInArchive">
             The name of the directory path to use within the zip archive. 
             This path need not refer to an extant directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB)) will use the path on the FileOrDirectoryName.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <example>
             This example shows how to zip up a set of files into a flat hierarchy, 
             regardless of where in the filesystem the files originated.
             <code>
             String[] itemnames= { 
               "c:\\temp\\Readme.txt",
               "MyProposal.docx",
               "SupportFiles",  // a directory
               "images\\Image1.jpg"
             };
            
             try
             {
               using (ZipFile zip = new ZipFile(ZipToCreate,System.Console.Out))
               {
                 for (int i = 1; i &lt; itemnames.Length; i++)
                 {
                   // will add Files or Dirs, recurses and flattens subdirectories
                   zip.AddItem(itemnames[i],"flat"); 
                 }
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code><code lang="VB">
               Dim itemnames As String() = _
                 New String() { "c:\temp\Readme.txt", _
                                "MyProposal.docx", _
                                "SupportFiles", _
                                "images\Image1.jpg" }
               Try 
                   Using zip As New ZipFile(ZipToCreate, Console.Out)
                       Dim i As Integer
                       For i = 1 To itemnames.Length - 1
                           ' will add Files or Dirs, recursing and flattening subdirectories.
                           zip.AddItem(itemnames(i), "flat")
                       Next i
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString())
               End Try
             </code></example>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFile(System.String)">
      <summary>
             Adds a File to a Zip file archive. 
             </summary>
      <remarks>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called photos\personal.  The pdf file will be included into a
             folder within the zip called Desktop.
             </para>
        <code>
                try
                {
                  using (ZipFile zip = new ZipFile("test2.zip",System.Console.Out))
                  {
                    zip.AddFile("c:\\photos\\personal\\7440-N49th.png");
                    zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf");
                    zip.AddFile("ReadMe.txt");
            
                    zip.Save();
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: " + ex1);
                }
             </code>
        <code lang="VB">
              Try 
                   Using zip As ZipFile = New ZipFile("test2.zip", Console.Out)
                       zip.AddFile("c:\photos\personal\7440-N49th.png")
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf")
                       zip.AddFile("ReadMe.txt")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code>
      </example>
      <overloads>This method has two overloads.</overloads>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <param name="fileName">
             The name of the file to add. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <returns>The ZipEntry corresponding to the File added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)">
      <summary>
             Adds a File to a Zip file archive, potentially overriding the path to be used
             within the zip archive.
             </summary>
      <remarks>
        <para>
             The file added by this call to the ZipFile is not written to the zip file
             archive until the application calls Save() on the ZipFile. 
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive. 
             </para>
      </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive. The .png file will be placed in a folder 
             within the zip called images.  The pdf file will be included into a
             folder within the zip called files\docs, and will be encrypted with the 
             given password.
             </para>
        <code>
             try
             {
               using (ZipFile zip = new ZipFile("Archive.zip",System.Console.Out))
               {
                 // the following entry will be inserted at the root in the archive.
                 zip.AddFile("c:\\datafiles\\ReadMe.txt", "");
                 // this image file will be inserted into the "images" directory in the archive.
                 zip.AddFile("c:\\photos\\personal\\7440-N49th.png", "images");
                 // the following will result in a password-protected file called 
                 // files\\docs\\2005_Annual_Report.pdf  in the archive.
                 zip.Password = "EncryptMe!";
                 zip.AddFile("c:\\Desktop\\2005_Annual_Report.pdf", "files\\docs");
                 zip.Save();
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code>
        <code lang="VB">
               Try 
                   Using zip As ZipFile = New ZipFile("Archive.zip", Console.Out)
                       ' the following entry will be inserted at the root in the archive.
                       zip.AddFile("c:\datafiles\ReadMe.txt", "")
                       ' this image file will be inserted into the "images" directory in the archive.
                       zip.AddFile("c:\photos\personal\7440-N49th.png", "images")
                       ' the following will result in a password-protected file called 
                       ' files\\docs\\2005_Annual_Report.pdf  in the archive.
                       zip.Password = "EncryptMe!"
                       zip.AddFile("c:\Desktop\2005_Annual_Report.pdf", "files\documents")
                       zip.Save
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1)
               End Try
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <param name="fileName">
             The name of the file to add.  The name of the file may be a relative path or 
             a fully-qualified path.
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <returns>The ZipEntry corresponding to the file added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String)">
      <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
      <remarks>
        <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.  
             The <c>UpdateFile</c> method might more accurately be called "AddOrUpdateFile".
             </para>
        <para>
             Upon success, there is no way for the application to learn  whether the file was added versus updated. 
             </para>
      </remarks>
      <example>
             This example shows how to Update an existing entry in a zipfile. The first call to 
             UpdateFile adds the file to the newly-created zip archive.  The second 
             call to UpdateFile updates the content for that file in the zip archive.
             <code>
             using (ZipFile zip1 = new ZipFile())
             {
               // UpdateFile might more accurately be called "AddOrUpdateFile"
               zip1.UpdateFile("MyDocuments\\Readme.txt", "");
               zip1.UpdateFile("CustomerList.csv", "");
               zip1.Comment = "This zip archive has been created.";
               zip1.Save("Content.zip");
             }
             
             using (ZipFile zip2 = ZipFile.Read("Content.zip"))
             {
               zip2.UpdateFile("Updates\\Readme.txt", "");
               zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed.";
               zip2.Save();
             }
            
             </code><code lang="VB">
               Using zip1 As New ZipFile
                   ' UpdateFile might more accurately be called "AddOrUpdateFile"
                   zip1.UpdateFile("MyDocuments\Readme.txt", "")
                   zip1.UpdateFile("CustomerList.csv", "")
                   zip1.Comment = "This zip archive has been created."
                   zip1.Save("Content.zip")
               End Using
            
               Using zip2 As ZipFile = ZipFile.Read("Content.zip")
                   zip2.UpdateFile("Updates\Readme.txt", "")
                   zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."
                   zip2.Save
               End Using
             </code></example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)">
      <summary>
             Adds or Updates a File in a Zip file archive.
             </summary>
      <remarks>
        <para>
             This method adds a file to a zip archive, or, if the file already exists in the zip archive, 
             this method Updates the content of that given filename in the zip archive.
             </para>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used in the archive.  The entry to be added or updated is found by 
             using the specified directory path, combined with the basename of the specified 
             filename. 
             </para>
        <para>
             Upon success, there is no way for the application to learn whether the file was added or updated. 
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <param name="fileName">
             The name of the file to add or update. It should refer to a file in the filesystem.  
             The name of the file may be a relative path or a fully-qualified path. 
             </param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the FileName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <returns>The ZipEntry corresponding to the File that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)">
      <summary>
             Add or Update a Directory in a zip archive.
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
      <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String)" />
      <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
      <returns>The ZipEntry corresponding to the Directory that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)">
      <summary>
             Add or Update a directory in the zip archive at the specified root directory in the archive.  
             If the directory has already been added to the archive,
             its contents are updated.  If not, then the directory is added.
             </summary>
      <remarks>
             If the specified directory does not exist in the archive, then this method is equivalent to
             calling AddDirectory().  If the specified directory already exists in the archive, then this 
             method updates any existing entries, and adds any new entries. Any entries that are in the 
             zip archive but not in the specified directory, are left alone.  In other words, the contents of 
             the zip file is a union of the previous contents and the new files.
             </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)" />
      <param name="directoryName">The path to the directory to be added to the zip archive, 
             or updated in the zip archive.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <returns>The ZipEntry corresponding to the Directory that was added or updated.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String)">
      <summary>
             Add or Update a File or Directory in the zip archive. This
             is useful when the application is not sure or does not care
             if the entries in the existing zip archive already exist.
             </summary>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <param name="itemName">the path to the file or directory to be added or updated.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateItem(System.String,System.String)">
      <summary>
             Add or Update a File or Directory.  This is useful when the application is not sure or does not 
             care if the entries in the existing zip archive already exist.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to explicitly specify the 
             directory path to be used for the item being added to the archive.  The entry or entries 
             that are added or updated will use the specified <c>DirectoryPathInArchive</c>. Extracting
             the entry from the archive will result in a file stored in that directory path. 
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <param name="itemName">The path for the File or Directory to be added or updated.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)">
      <summary>
             Uses the given stream as input to create an entry in the ZipFile, with the 
             given FileName and given Directory Path.  
             </summary>
      <remarks>
        <para>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save</c>.
             </para>
        <para>
             Encryption will be used on the stream data when saving the 
             ZipFile, if the Password is set on the ZipFile object prior to calling
             this method.</para>
      </remarks>
      <example>
        <code lang="C#">
             String ZipToCreate = "Content.zip";
             String FileNameInArchive = "Content-From-Stream.bin";
             using (ZipFile zip = new ZipFile(ZipToCreate))
             {
               ZipEntry entry= zip.AddFileStream(FileNameInArchive, "basedirectory", StreamToRead);
               entry.Comment = "The content for entry in the zip file was obtained from a stream";
               zip.AddFile("Readme.txt");
               zip.Save();
             }
             
             </code>
        <code lang="VB">
             Dim ZipToCreate As String = "Content.zip"
             Dim FileNameInArchive As String = "Content-From-Stream.bin"
             Using zip As ZipFile = New ZipFile(ZipToCreate)
               Dim entry as ZipEntry = zip.AddFileStream(FileNameInArchive, "basedirectory", Me.StreamToRead)
               entry.Comment = "The content for entry in the zip file was obtained from a stream"
               zip.AddFile("Readme.txt")
               zip.Save
             End Using
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)" />
      <param name="fileName">FileName which is shown in the ZIP File</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the ItemName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the files within the zip are later extracted, this is the path used for the extracted file. 
             Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
             will insert the item at the root path within the archive. 
             </param>
      <param name="stream">the input stream from which to grab content for the file</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddFileFromString(System.String,System.String,System.String)">
      <summary>
            Adds an entry into the zip archive using the given filename and directory path within the archive,
            and the given content for the file.  No file is created in the filesystem.  
            </summary>
      <param name="content">The content of the file, should it be extracted from the zip.</param>
      <param name="fileName">The filename to use within the archive.</param>
      <param name="directoryPathInArchive">
            Specifies a driectory path to use to override any path in the ItemName.
            This path may, or may not, correspond to a real directory in the current filesystem.
            If the files within the zip are later extracted, this is the path used for the extracted file. 
            Passing null (nothing in VB) will use the path on the FileName, if any.  Passing the empty string ("")
            will insert the item at the root path within the archive. 
            </param>
      <returns>The ZipEntry added.</returns>
      <example>
            This example shows how to add an entry to the zipfile, using a string as content for that entry. 
            <code lang="C#">
            string Content = "This string will be the content of the Readme.txt file in the zip archive.";
            using (ZipFile zip1 = new ZipFile())
            {
              zip1.AddFile("MyDocuments\\Resume.doc", "files");
              zip1.AddFileFromString("Readme.txt", "", Content); 
              zip1.Comment = "This zip file was created at " + System.DateTime.Now.ToString("G");
              zip1.Save("Content.zip");
            }
            
            </code><code lang="VB">
            Public Sub Run()
              Dim Content As String = "This string will be the content of the Readme.txt file in the zip archive."
              Using zip1 As ZipFile = New ZipFile
                zip1.AddFileFromString("Readme.txt", "", Content)
                zip1.AddFile("MyDocuments\Resume.doc", "files")
                zip1.Comment = ("This zip file was created at " &amp; DateTime.Now.ToString("G"))
                zip1.Save("Content.zip")
              End Using
            End Sub
            </code></example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.UpdateFileStream(System.String,System.String,System.IO.Stream)">
      <summary>
             Updates the given entry in the zipFile, using the given stream as input, and the
             given FileName and given Directory Path.  Encryption will be used on the 
             stream data if the Password is set on the ZipFile object, prior to calling
             this method.
             </summary>
      <remarks>
             The stream must remain open and readable at least through the call to 
             <c>ZipFile.Save</c>.
             </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)" />
      <param name="fileName">FileName which is shown in the ZIP File</param>
      <param name="directoryPathInArchive">The root path to be used in the ZIP archive, 
             for the entry added from the stream.</param>
      <param name="stream">The Input Stream to read file data from.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String)">
      <summary>
             Adds the contents of a filesystem directory to a Zip file archive. 
             </summary>
      <remarks>
        <para>
             The name of the directory may be 
             a relative path or a fully-qualified path. Any files within the named 
             directory are added to the archive.  Any subdirectories within the named
             directory are also added to the archive, recursively. 
             </para>
        <para>
             Top-level entries in the named directory will appear as top-level 
             entries in the zip archive.  Entries in subdirectories in the named 
             directory will result in entries in subdirectories in the zip archive.
             </para>
        <para>
             If you want the entries to appear in a containing directory in the zip
             archive itself, then you should call the AddDirectory() overload that allows
             you to explicitly specify a containing directory.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)" />
      <overloads>This method has 2 overloads.</overloads>
      <param name="directoryName">The name of the directory to add.</param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectory(System.String,System.String)">
      <summary>
             Adds the contents of a filesystem directory to a Zip file archive, 
             overriding the path to be used for entries in the archive. 
             </summary>
      <remarks>
        <para>
             The name of the directory may be a relative path or a fully-qualified
             path. The add operation is recursive, so that any files or subdirectories
             within the name directory are also added to the archive.
             </para>
      </remarks>
      <example>
        <para>
             In this code, calling the ZipUp() method with a value of "c:\temp" for the
             directory parameter will result in a zip file structure in which all entries
             are contained in a toplevel "temp" directory.
             </para>
        <code lang="C#">
             public void ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile())
               {
                 zip.AddDirectory(directory, System.IO.Path.GetFileName(directory));
                 zip.Save(targetZip);
               }
             }
             </code>
      </example>
      <seealso cref="M:Ionic.Zip.ZipFile.AddItem(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.AddFile(System.String,System.String)" />
      <seealso cref="M:Ionic.Zip.ZipFile.UpdateDirectory(System.String,System.String)" />
      <param name="directoryName">The name of the directory to add.</param>
      <param name="directoryPathInArchive">
             Specifies a directory path to use to override any path in the DirectoryName.
             This path may, or may not, correspond to a real directory in the current filesystem.
             If the zip is later extracted, this is the path used for the extracted file or directory. 
             Passing null (nothing in VB) or the empty string ("")
             will insert the items at the root path within the archive. 
             </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.AddDirectoryByName(System.String)">
      <summary>
             Creates a directory in the zip archive.  
             </summary>
      <remarks>
        <para>
             Use this when you want to create a directory in the archive but there is no
             corresponding filesystem representation for that directory.
             </para>
        <para>
             You will probably not need to do this in your code. One of the only times
             you will want to do this is if you want an empty directory in the zip
             archive.  If you add a file to a zip archive that is stored within a
             multi-level directory, all of the directory tree is implicitly created in
             the zip archive.  
             </para>
      </remarks>
      <param name="directoryNameInArchive">
             The name of the directory to create in the archive.
             </param>
      <returns>The ZipEntry added.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save">
      <summary>
             Saves the Zip archive, using the name given when the ZipFile was instantiated. 
             </summary>
      <remarks>
        <para>
             The zip file is written to storage only when the caller calls <c>Save</c>.  
             The Save operation writes the zip content to a temporary file. 
             Then, if the zip file already exists (for example when adding an item to a zip archive)
             this method will replace the existing zip file with this temporary file.
             If the zip file does not already exist, the temporary file is renamed 
             to the desired name.  
             </para>
        <para>
             When using a filesystem file for the Zip output, it is possible to call
             <c>Save</c> multiple times on the ZipFile instance. With each call the zip content
             is written to the output file. When saving to a <c>Stream</c>, after the initial
             call to <c>Save</c>, additional calls to <c>Save</c> will throw. This is because the
             stream is assumed to be a write-only stream, and after the initial <c>Save</c>, it
             is not possible to seek backwards and "unwrite" the zip file data.
             </para>
        <para>
             Data for entries that have been added to the <c>ZipFile</c> instance is written
             to the output when the <c>Save</c> method is called. This means that the input
             streams for those entries must be available at the time the application
             calls <c>Save</c>.  If, for example, the application adds entries with
             <c>AddFileStream</c> using a dynamically-allocated <c>MemoryStream</c>,
             the memory stream must not have been disposed before the call to <c>Save</c>.
             </para>
        <para>
             When using the zip library within an ASP.NET application, you may wish to set the
             <c>TempFileFolder</c> property on the <c>ZipFile</c> instance before calling Save().
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.AddFileStream(System.String,System.String,System.IO.Stream)" />
      <exception cref="T:Ionic.Zip.BadStateException">
             Thrown if you haven't specified a location or stream for saving the zip,
             either in the constructor or by setting the Name property. 
             </exception>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save(System.String)">
      <summary>
             Save the file to a new zipfile, with the given name. 
             </summary>
      <remarks>
        <para>
             This is handy when reading a zip archive from a stream 
             and you want to modify the archive (add a file, change a 
             comment, etc) and then save it to a file. 
             </para>
        <para>
             It also works if you create a new ZipFile for writing to a 
             stream, and then you also want to write it to a filesystem file. 
             In that case, call the Save() method, and then also call this method with
             a filename. 
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if you specify a directory for the filename.
             </exception>
      <param name="zipFileName">
             The name of the zip archive to save to. Existing files will 
             be overwritten with great prejudice.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Save(System.IO.Stream)">
      <summary>
            Save the zip archive to the specified stream.
            </summary>
      <param name="outputStream">The <c>System.IO.Stream</c> to write to. It must be writable.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String)">
      <summary>
            Checks the given file to see if it appears to be a valid zip file.
            </summary>
      <remarks>
        <para>
            Calling this method is equivalent to calling 
            <see cref="M:Ionic.Zip.ZipFile.IsZipFile(System.String)" />.
            </para>
      </remarks>
      <param name="fileName">The file to check.</param>
      <returns>true if the file appears to be a zip file.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.IsZipFile(System.String,System.Boolean)">
      <summary>
             Checks a to see if a file is a valid zip file.
             </summary>
      <remarks>
        <para>
             This method opens the specified zip file, reads in the zip archive, verifying
             the ZIP metadata as it reads.  Then, if testExtract is true, this method extracts 
             each entry in the archive, dumping all the bits. 
             </para>
        <para>
             If everything succeeds, then the method
             returns true.  If anything fails - for example if an incorrect signature or CRC
             is found, indicating a corrupt file, the the method returns false.  This method also returns false
             for a file that does not exist. 
             </para>
        <para>
             If <c>testExtract</c> is true, this method reads in the content for each
             entry, expands it, and checks CRCs.  This provides an additional check
             beyond verifying the zip header data.
             </para>
        <para>
             If <c>testExtract</c> is true, and if any of the zip entries are protected
             with a password, this method will return false.  If you want to verify a
             ZipFile that has entries which are protected with a password, you will need
             to do that manually.
             </para>
      </remarks>
      <param name="fileName">The zip file to check.</param>
      <param name="testExtract">true if the caller wants to extract each entry.</param>
      <returns>true if the file appears to be a valid zip file.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String)">
      <summary>
             Reads a zip file archive and returns the instance.  
             </summary>
      <remarks>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
      </remarks>
      <exception cref="T:System.Exception">
             Thrown if the ZipFile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <overloads>This method has a bunch of interesting overloads. They are all static (Shared in VB)</overloads>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip file archive and returns the instance, using the specified
            ReadProgress event handler.  
            </summary>
      <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter)">
      <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c>.  
             The ZipFile is read in using the default IBM437 encoding for entries where UTF-8 
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
        <code lang="C#">
             var sw = new System.IO.StringWriter();
             using (ZipFile zip =  ZipFile.Read("PackedDocuments.zip", sw))
             {
               var Threshold = new DateTime(2007,7,4);
               // We cannot remove the entry from the list, within the context of 
               // an enumeration of said list.
               // So we add the doomed entry to a list to be removed later.
               // pass 1: mark the entries for removal
               var MarkedEntries = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                   MarkedEntries.Add(e);
               }
               // pass 2: actually remove the entry. 
               foreach (ZipEntry zombie in MarkedEntries)
                  zip.RemoveEntry(zombie);
               zip.Comment = "This archive has been updated.";
               zip.Save();
             }
             // can now use contents of sw, eg store in an audit log
             </code>
        <code lang="VB">
               Dim sw As New System.IO.StringWriter
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip", sw)
                   Dim Threshold As New DateTime(2007, 7, 4)
                   ' We cannot remove the entry from the list, within the context of 
                   ' an enumeration of said list.
                   ' So we add the doomed entry to a list to be removed later.
                   ' pass 1: mark the entries for removal
                   Dim MarkedEntries As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           MarkedEntries.Add(e)
                       End If
                   Next
                   ' pass 2: actually remove the entry. 
                   Dim zombie As ZipEntry
                   For Each zombie In MarkedEntries
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = "This archive has been updated."
                   zip.Save
               End Using
               ' can now use contents of sw, eg store in an audit log
             </code>
      </example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip file archive using the specified text encoding, and the
            specified ReadProgress event handler, and returns the instance.  
            </summary>
      <param name="zipFileName">
            The name of the zip archive to open.  
            This can be a fully-qualified or relative pathname.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <param name="statusMessageWriter">
            The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
            on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
            messages on the Console. A graphical or headless application may wish to capture the messages 
            in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
            </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding)">
      <summary>
             Reads a zip file archive using the specified text encoding, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in an <c>Encoding</c>.  
             The ZipFile is read in using the specified encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the Big-5 Chinese code page (950), 
             and extract each entry in the zip file.
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code></example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>.
            
             <returns>The instance read from the zip archive.</returns></member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip file archive using the specified text encoding and ReadProgress
             event handler, and returns the instance.  
             </summary>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip file archive using the specified text encoding and the specified
             TextWriter for status messages, and returns the instance.  
             </summary>
      <remarks>
        <para>
             This version of the method allows the caller to pass in a <c>TextWriter</c> and an <c>Encoding</c>.  
             The ZipFile is read in using the specified encoding for entries where UTF-8
             encoding is not explicitly specified.
             </para>
      </remarks>
      <example>
             This example shows how to read a zip file using the Big-5 Chinese code page (950), 
             and extract each entry in the zip file, while sending status messages out to the Console. 
             <code lang="C#">
             using (ZipFile zip = ZipFile.Read(ZipToExtract,
                                               System.Console.Out,
                                               System.Text.Encoding.GetEncoding(950)))
             {
               foreach (ZipEntry e in zip)
               {
                  e.Extract(extractDirectory);
               }
             }
             </code></example>
      <exception cref="T:System.Exception">
             Thrown if the zipfile cannot be read. The implementation of this 
             method relies on <c>System.IO.File.OpenRead</c>, which can throw
             a variety of exceptions, including specific exceptions if a file
             is not found, an unauthorized access exception, exceptions for
             poorly formatted filenames, and so on. 
             </exception>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions.  
             </param>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.String,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip file archive using the specified text encoding,  the specified
             TextWriter for status messages, and the specified ReadProgress event handler, 
             and returns the instance.  
             </summary>
      <param name="zipFileName">
             The name of the zip archive to open.  
             This can be a fully-qualified or relative pathname.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to use for writing verbose status messages during operations
             on the zip archive.  A console application may wish to pass <c>System.Console.Out</c> to get 
             messages on the Console. A graphical or headless application may wish to capture the messages 
             in a different <c>TextWriter</c>, such as a <c>System.IO.StringWriter</c>. 
             </param>
      <param name="encoding">
             The <c>System.Text.Encoding</c> to use when reading in the zip archive. Be careful specifying the
             encoding.  If the value you use here is not the same as the Encoding used when the zip archive was 
             created (possibly by a different archiver) you will get unexpected results and possibly exceptions. 
             </param>
      <returns>The instance read from the zip archive.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream)">
      <summary>
             Reads a zip archive from a stream.
             </summary>
      <remarks>
        <para>
             This is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             </para>
      </remarks>
      <example>
             This example shows how to Read zip content from a stream, and extract
             one entry into a different stream. In this example, the filename
             "NameOfEntryInArchive.doc", refers only to the name of the entry
             within the zip archive.  A file by that name is not created in the
             filesystem.  The I/O is done strictly with the given streams.
             <code>
             using (ZipFile zip = ZipFile.Read(InputStream))
             {
               zip.Extract("NameOfEntryInArchive.doc", OutputStream);
             }
             </code><code lang="VB">
             Using zip as ZipFile = ZipFile.Read(InputStream)
               zip.Extract("NameOfEntryInArchive.doc", OutputStream)
             End Using
             </code></example>
      <param name="zipStream">the stream containing the zip data.</param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, with a given ReadProgress event handler.
             </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile corresponding to the stream being read.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter)">
      <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status messages.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
        <para>
             The stream is read using the default <c>System.Text.Encoding</c>, which is the <c>IBM437</c> codepage.  
             For more information on the encoding, see the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see> property.
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, using the specified TextWriter for status messages, 
             and the specified ReadProgress event handler.
             </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a stream, using the specified encoding.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
            Reads a zip archive from a stream, using the specified encoding, and
            and the specified ReadProgress event handler.
            </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="encoding">
            The text encoding to use when reading entries that do not have the UTF-8 encoding
            bit set.  Be careful specifying the encoding.  If the value you use here is not the
            same as the Encoding used when the zip archive was created (possibly by a different
            archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
            property for more information.
            </param>
      <param name="readProgress">
            An event handler for Read operations.
            </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a stream, using the specified text Encoding and the 
             specified TextWriter for status messages.
             </summary>
      <remarks>
        <para>
             This method is useful when when the zip archive content is available from 
             an already-open stream. The stream must be open and readable when calling this
             method.  The stream is left open when the reading is completed. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if zipStream is null.
             In this case, the inner exception is an ArgumentException.
             </exception>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.IO.Stream,System.IO.TextWriter,System.Text.Encoding,System.EventHandler{Ionic.Zip.ReadProgressEventArgs})">
      <summary>
             Reads a zip archive from a stream, using the specified text Encoding, the 
             specified TextWriter for status messages, 
             and the specified ReadProgress event handler.
             </summary>
      <param name="zipStream">the stream containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</see>
             property for more information.
             </param>
      <param name="readProgress">
             An event handler for Read operations.
             </param>
      <returns>an instance of ZipFile</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[])">
      <summary>
            Reads a zip archive from a byte array.
            </summary>
      <remarks>
            This is useful when the data for the zipfile is contained in a byte array, 
            for example, downloaded from an FTP server without being saved to a
            filesystem. 
            </remarks>
      <param name="buffer">
            The byte array containing the zip data.  
            (I don't know why, but sometimes the compiled helpfuile (.chm) indicates a 2d 
            array when it is just one-dimensional.  This is a one-dimensional array.)
            </param>
      <returns>an instance of ZipFile. The name on the ZipFile will be null (nothing in VB)). </returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter)">
      <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter.
             </summary>
      <remarks>
        <para>
             This method is useful when the data for the zipfile is contained in a byte array, for
             example when retrieving the data from a database or other non-filesystem store.  
             The default Text Encoding (IBM437) is used to read the zipfile data.
             </para>
      </remarks>
      <param name="buffer">the byte array containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <returns>an instance of ZipFile. The name is set to null.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Read(System.Byte[],System.IO.TextWriter,System.Text.Encoding)">
      <summary>
             Reads a zip archive from a byte array, using the given StatusMessageWriter and text Encoding.
             </summary>
      <remarks>
        <para>
             This method is useful when the data for the zipfile is contained in a byte array, for
             example when retrieving the data from a database or other non-filesystem store.  
             </para>
      </remarks>
      <param name="buffer">the byte array containing the zip data.</param>
      <param name="statusMessageWriter">
             The <c>System.IO.TextWriter</c> to which verbose status messages are written during
             operations on the ZipFile.  For example, in a console application,
             System.Console.Out works, and will get a message for each entry added to the
             ZipFile.  If the TextWriter is null, no verbose messages are written.
             </param>
      <param name="encoding">
             The text encoding to use when reading entries that do not have the UTF-8 encoding
             bit set.  Be careful specifying the encoding.  If the value you use here is not the
             same as the Encoding used when the zip archive was created (possibly by a different
             archiver) you will get unexpected results and possibly exceptions.  See the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />
             property for more information.
             </param>
      <returns>an instance of ZipFile. The name is set to null.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.GetEnumerator">
      <summary>
             Generic IEnumerator support, for use of a ZipFile in a foreach construct.  
             </summary>
      <remarks>
             You probably do not want to call <c>GetEnumerator</c> explicitly. Instead 
             it is implicitly called when you use a <c>foreach</c> loop in C#, or a 
             <c>For Each</c> loop in VB.
             </remarks>
      <example>
             This example reads a zipfile of a given name, then enumerates the 
             entries in that zip file, and displays the information about each 
             entry on the Console.
             <code>
             using (ZipFile zip = ZipFile.Read(zipfile))
             {
               bool header = true;
               foreach (ZipEntry e in zip)
               {
                 if (header)
                 {
                    System.Console.WriteLine("Zipfile: {0}", zip.Name);
                    System.Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded);
                    System.Console.WriteLine("BitField: 0x{0:X2}", e.BitField);
                    System.Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod);
                    System.Console.WriteLine("\n{1,-22} {2,-6} {3,4}   {4,-8}  {0}",
                                 "Filename", "Modified", "Size", "Ratio", "Packed");
                    System.Console.WriteLine(new System.String('-', 72));
                    header = false;
                 }
            
                 System.Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}",
                             e.FileName,
                             e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"),
                             e.UncompressedSize,
                             e.CompressionRatio,
                             e.CompressedSize);
            
                 e.Extract();
               }
             }
             </code><code lang="VB">
               Dim ZipFileToExtract As String = "c:\foo.zip"
               Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                   Dim header As Boolean = True
                   Dim e As ZipEntry
                   For Each e In zip
                       If header Then
                           Console.WriteLine("Zipfile: {0}", zip.Name)
                           Console.WriteLine("Version Needed: 0x{0:X2}", e.VersionNeeded)
                           Console.WriteLine("BitField: 0x{0:X2}", e.BitField)
                           Console.WriteLine("Compression Method: 0x{0:X2}", e.CompressionMethod)
                           Console.WriteLine(ChrW(10) &amp; "{1,-22} {2,-6} {3,4}   {4,-8}  {0}", _
                             "Filename", "Modified", "Size", "Ratio", "Packed" )
                           Console.WriteLine(New String("-"c, 72))
                           header = False
                       End If
                       Console.WriteLine("{1,-22} {2,-6} {3,4:F0}%   {4,-8}  {0}", _
                         e.FileName, _
                         e.LastModified.ToString("yyyy-MM-dd HH:mm:ss"), _
                         e.UncompressedSize, _
                         e.CompressionRatio, _
                         e.CompressedSize )
                       e.Extract
                   Next
               End Using
             </code></example>
      <returns>A generic enumerator suitable for use  within a foreach loop.</returns>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String)">
      <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem.
             The path can be relative or fully-qualified. 
             </summary>
      <remarks>
        <para>
             If an extraction of a file from the zip archive would overwrite an existing file
             in the filesystem, the file will not be overwritten and an exception will be
             thrown. To avoid this, use the overload that allows you to specify that you want
             to overwrite existing files.
             </para>
        <para>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </para>
        <para>
             You may wish to take advantage of the <c>ExtractProgress</c> event.
             </para>
      </remarks>
      <seealso cref="M:Ionic.Zip.ZipFile.ExtractAll(System.String,System.Boolean)" />
      <seealso cref="E:Ionic.Zip.ZipFile.ExtractProgress" />
      <param name="path">The path to which the contents of the zip archive should be extracted.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.ExtractAll(System.String,System.Boolean)">
      <summary>
             Extracts all of the items in the zip archive, to the specified path in the filesystem,  
             optionally overwriting any existing files. The path can be relative or fully-qualified. 
             </summary>
      <remarks>
             This method will send verbose output messages to the StatusMessageTextWriter, if it 
             is set on the ZipFile instance. 
             </remarks>
      <example>
             This example extracts all the entries in a zip archive file, 
             to the specified target directory.  It overwrites any existing files.
             It also handles exceptions that may be thrown, such as unauthorized 
             access exceptions.
             <code>
             String TargetDirectory= "c:\\temp\\unpack";
             try 
             {
               using(ZipFile zip= ZipFile.Read(ZipFileToExtract))
               {
                 zip.ExtractAll(TargetDirectory, true);
               }
             }
             catch (System.Exception ex1)
             {
               System.Console.Error.WriteLine("exception: {0}", ex1);
             }
             </code><code lang="VB">
               Dim TargetDirectory As String = "c:\temp\unpack"
               Try 
                   Using zip As ZipFile = ZipFile.Read(ZipFileToExtract)
                       zip.ExtractAll(TargetDirectory, True)
                   End Using
               Catch ex1 As Exception
                   Console.Error.WriteLine("exception: {0}", ex1.ToString)
               End Try
             </code></example>
      <param name="path">the path to which the contents of the zipfile are extracted.</param>
      <param name="wantOverwrite">true to overwrite any existing files on extraction</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String)">
      <summary>
             Extract a single item from the archive.  The file, including any relative
             qualifying path, is created at the current working directory.  
             </summary>
      <remarks>
        <para>
             Using this method, the entry is extracted using the Password that is specified on
             the ZipFile instance. If you have not set the Password property, then the password
             is null, and the entry is extracted with no password.  The file, including any
             relative qualifying path, is created at the current working directory.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="fileName">
             The file to extract. It must be the exact filename, including the path
             contained in the archive, if any. The filename match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change
             this behavior.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.String)">
      <summary>
             Extract a single item from the archive.  The file, including any relative
             qualifying path, is created at the current working directory.  
             </summary>
      <remarks>
        <para>
             Calling this method, the entry is extracted using the Password that is specified on
             the ZipFile instance. If you have not set the Password property, then the password
             is null, and the entry is extracted with no password.  The file, including any
             relative qualifying path, is created at the specified directory.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="fileName">
             the file to extract. It must be the exact filename, including the path
             contained in the archive, if any. The filename match is not case-sensitive by
             default; you can use the <c>CaseSensitiveRetrieval</c> property to change
             this behavior.
             </param>
      <param name="directoryName">the directory into which to extract. It should exist.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.Boolean)">
      <summary>
             Extract a single item from the archive, potentially overwriting  
             any existing file in the filesystem by the same name.
             </summary>
      <remarks>
        <para>
             Using this method, the entry is extracted using the Password that is specified on
             the ZipFile instance. If you have not set the Password property, then the password
             is null, and the entry is extracted with no password.  The file, including any
             relative qualifying path, is created at the current working directory.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="fileName">
             The file to extract. It must be the exact filename, including the path contained in the 
             archive, if any. The filename match is not case-sensitive by default; you can use the <c>CaseSensitiveRetrieval</c> 
             property to change this behavior.
             The pathname can use forward-slashes or backward slashes.
             </param>
      <seealso cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" />
      <param name="wantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.String,System.Boolean)">
      <summary>
             Extract a single item from the archive, into the specified directory, potentially overwriting  
             any existing file in the filesystem by the same name.   
             </summary>
      <remarks>
        <para>
             Calling this method, the entry is extracted using the Password that is specified on
             the ZipFile instance. If you have not set the Password property, then the password
             is null, and the entry is extracted with no password.  The file, including any
             relative qualifying path, is created at the specified directory.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <param name="fileName">
             The file to extract. It must be the exact filename, including the path contained in the archive, 
             if any. The filename match is not case-sensitive by default; you can use the <c>CaseSensitiveRetrieval</c> 
             property to change this behavior. The pathname can use forward-slashes or backward slashes.
             </param>
      <param name="directoryName">the directory into which to extract. It should exist.</param>
      <param name="wantOverwrite">True if the caller wants to overwrite any existing files by the given name.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Extract(System.String,System.IO.Stream)">
      <summary>
             Extract a single specified file from the archive, to the given stream.   
             </summary>
      <remarks>
        <para>
             Calling this method, the entry is extracted using the Password that is 
             specified on the ZipFile instance. If you have not set the Password property, then
             the password is null, and the entry is extracted with no password.
             </para>
        <para>
             The ExtractProgress event is invoked before and after extraction, if it has been set. 
             </para>
      </remarks>
      <exception cref="T:Ionic.Zip.ZipException">
             Thrown if the outputStream is not writable, or if the filename is 
             null or empty. The inner exception is an ArgumentException in each case.
             </exception>
      <param name="fileName">
             the file to extract. It should include pathnames used in the archive, if any.
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior.The
             application can specify pathnames using forward-slashes or backward slashes.
             </param>
      <param name="outputStream">
             the stream to which the extacted, decompressed file data is written. 
             The stream must be writable.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntry(Ionic.Zip.ZipEntry)">
      <summary>
             Removes the given ZipEntry from the zip archive.  
             </summary>
      <remarks>
        <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the 
             changes permanent.  
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if the specified ZipEntry does not exist in the ZipFile.
             </exception>
      <example>
             In this example, all entries in the zip archive dating from before December 31st, 2007, are
             removed from the archive.
             <code>
             System.DateTime Threshold = new System.DateTime(2007,12,31);
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               var EntriesToRemove = new System.Collections.Generic.List&lt;ZipEntry&gt;();
               foreach (ZipEntry e in zip)
               {
                 if (e.LastModified &lt; Threshold)
                 {
                   // We cannot remove the entry from the list, within the context of 
                   // an enumeration of said list.
                   // So we add the doomed entry to a list to be removed later.
                   EntriesToRemove.Add(e);
                 }
               }
               
               // actually remove the doomed entries. 
               foreach (ZipEntry zombie in EntriesToRemove)
                 zip.RemoveEntry(zombie);
               
               zip.Comment= String.Format("This zip archive was updated at {0}.", 
                                          System.DateTime.Now.ToString("G"));
               zip.Save();
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "c:\foo.zip"
               Dim Threshold As New DateTime(2007, 12, 31)
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   Dim EntriesToRemove As New System.Collections.Generic.List(Of ZipEntry)
                   Dim e As ZipEntry
                   For Each e In zip
                       If (e.LastModified &lt; Threshold) Then
                           ' We cannot remove the entry from the list, within the context of 
                           ' an enumeration of said list.
                           ' So we add the doomed entry to a list to be removed later.
                           EntriesToRemove.Add(e)
                       End If
                   Next
               
                   ' actually remove the doomed entries. 
                   Dim zombie As ZipEntry
                   For Each zombie In EntriesToRemove
                       zip.RemoveEntry(zombie)
                   Next
                   zip.Comment = String.Format("This zip archive was updated at {0}.", DateTime.Now.ToString("G"))
                   zip.Save
               End Using
             </code></example>
      <param name="entry">
             The ZipEntry to remove from the zip. 
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)">
      <summary>
             Removes the ZipEntry with the given filename from the zip archive.  
             </summary>
      <remarks>
        <para>
             After calling <c>RemoveEntry</c>, the application must call <c>Save</c> to make the changes permanent.  
             </para>
      </remarks>
      <exception cref="T:System.InvalidOperationException">
             Thrown if the ZipFile is not updatable. 
             </exception>
      <exception cref="T:System.ArgumentException">
             Thrown if a ZipEntry with the specified filename does not exist in the ZipFile.
             </exception>
      <example>
             This example shows one way to remove an entry with a given filename from an 
             existing zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
               {
                 zip.RemoveEntry(Candidate);
                 zip.Comment= String.Format("The file '{0}' has been removed from this archive.", 
                                            Candidate);
                 zip.Save();
               }
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As ZipFile = New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       zip.RemoveEntry(Candidate)
                       zip.Comment = String.Format("The file '{0}' has been removed from this archive.", Candidate)
                       zip.Save
                   End If
               End Using
             </code></example>
      <param name="fileName">
             The name of the file, including any directory path, to remove from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <c>CaseSensitiveRetrieval</c> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Finalize">
      <summary>
            This is the class Destructor, which gets called implicitly when the instance is destroyed.  
            Because the ZipFile type implements IDisposable, this method calls Dispose(false).  
            </summary>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Dispose">
      <summary>
            Handles closing of the read and write streams associated
            to the ZipFile, if necessary.  The Dispose() method is generally 
            employed implicitly, via a using() {} statement. 
            </summary>
      <example>
        <code>
            using (ZipFile zip = ZipFile.Read(zipfile))
            {
              foreach (ZipEntry e in zip)
              {
                if (WantThisEntry(e.FileName)) 
                  zip.Extract(e.FileName, Console.OpenStandardOutput());
              }
            } // Dispose() is called implicitly here.
            </code>
      </example>
    </member>
    <member name="M:Ionic.Zip.ZipFile.Dispose(System.Boolean)">
      <summary>
            The Dispose() method.  It disposes any managed resources, 
            if the flag is set, then marks the instance disposed.
            This method is typically not called from application code.
            </summary>
      <param name="disposeManagedResources">indicates whether the method should dispose streams or not.</param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor,System.String)">
      <summary>
            Saves the ZipFile instance to a self-extracting zip archive, using the specified 
            default extract directory. 
            </summary>
      <remarks>
        <para>
            This method saves a self extracting archive, 
            with a specified default extracting location.  Actually, the 
            default extract directory applies only if the flavor is 
             <see cref="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication" />.  
            See the documentation for 
            <see cref="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)" />
            for more details.  
            </para>
        <para>
            The user who runs the SFX will have the opportunity to change the extract
            directory before extracting. 
            If at the time of extraction, the specified directory does not exist, 
            the SFX will create the directory before extracting the files. 
            </para>
      </remarks>
      <param name="exeToGenerate">The name of the EXE to generate.</param>
      <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
      <param name="defaultExtractDirectory">
            The default extract directory the user will see when running the self-extracting 
            archive. Passing null (or Nothing in VB) here will cause the Self Extractor to 
            use the the user's personal directory 
            (<see cref="F:System.Environment.SpecialFolder.Personal" />) for the default extract 
            location.
            </param>
    </member>
    <member name="M:Ionic.Zip.ZipFile.SaveSelfExtractor(System.String,Ionic.Zip.SelfExtractorFlavor)">
      <summary>
             Saves the ZipFile instance to a self-extracting zip archive.
             </summary>
      <remarks>
        <para>
             The generated exe image will execute on any machine that has the .NET Framework 2.0
             installed on it.
             </para>
        <para>
             There are two "flavors" of self-extracting archive.  The <c>WinFormsApplication</c>
             version will pop up a GUI and allow the user to select a target directory into which
             to extract. There's also a checkbox allowing the user to specify to overwrite
             existing files, and another checkbox to allow the user to request that Explorer be
             opened to see the extracted files after extraction.  The other flavor is
             <c>ConsoleApplication</c>.  A self-extractor generated with that flavor setting will
             run from the command line. It accepts command-line options to set the overwrite
             behavior, and to specify the target extraction directory.
             </para>
        <para>
             There are a few temporary files created during the saving to a self-extracting zip. 
             These files are created in the directory pointed to by 
             <see cref="P:Ionic.Zip.ZipFile.TempFileFolder" />, which defaults to  <see cref="M:System.IO.Path.GetTempPath" />.
             These temporary files are removed upon successful completion of this method. 
             </para>
        <para>
             When a user runs the SFX, the user's personal directory 
             (<see cref="F:System.Environment.SpecialFolder.Personal" />) 
             will be used as the default extract location.
             The user who runs the SFX will have the opportunity to change the extract
             directory before extracting. 
             </para>
        <para>
             NB: This method is not available in the version of DotNetZip
             build for the .NET Compact Framework, nor in the "Reduced" DotNEtZip library.  
             </para>
      </remarks>
      <example>
        <code>
             string DirectoryPath = "c:\\Documents\\Project7";
             using (ZipFile zip = new ZipFile())
             {
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath));
                 zip.Comment = "This will be embedded into a self-extracting console-based exe";
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication);
             }
             </code>
        <code lang="VB">
             Dim DirectoryPath As String = "c:\Documents\Project7"
             Using zip As New ZipFile()
                 zip.AddDirectory(DirectoryPath, System.IO.Path.GetFileName(DirectoryPath))
                 zip.Comment = "This will be embedded into a self-extracting console-based exe"
                 zip.SaveSelfExtractor("archive.exe", SelfExtractorFlavor.ConsoleApplication)
             End Using
             </code>
      </example>
      <param name="exeToGenerate">a pathname, possibly fully qualified, to be created. Typically it will end in an .exe extension.</param>
      <param name="flavor">Indicates whether a Winforms or Console self-extractor is desired.</param>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Name">
      <summary>
            This read-only property specifies the name of the zipfile to read or
            write. It can be implicitly set when the instance of the ZipFile type is
            created, if you use the <see cref="M:Ionic.Zip.ZipFile.#ctor(System.String)" /> Constructor, or it is
            set when <see cref="M:Ionic.Zip.ZipFile.Save(System.String)" /> is called. When instantiating a
            ZipFile to read from or write to a stream, the Name property remains null.
            </summary>
    </member>
    <member name="P:Ionic.Zip.ZipFile.CompressionLevel">
      <summary>
            Sets the compression level to be used for entries when saving the zip archive.
            </summary>
      <remarks>
            The compression level setting is used at the time of Save(). The
            same level is applied to all ZipEntry instances contained in the ZipFile during the save.  
            If you do not set this property, the default compression level is used, which normally gives 
            a good balance of compression efficiency and compression speed.  In some tests, using 
            BEST_COMPRESSION can double the time it takes to compress, while delivering just a small
            increase in compression efficiency.  This behavior will vary with the type of data you 
            compress.  If you are in doubt, just leave this setting alone, and accept the default.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Comment">
      <summary>
             A comment attached to the zip archive.
             </summary>
      <remarks>
        <para>
             This property is read/write for the zipfile. It allows the application to
             specify a comment for the zipfile, or read the comment for the zipfile. 
             After setting this property, changes are only made permanent when you call a
             <c>Save()</c> method.
             </para>
        <para>
             According to the zip specification, the comment is not encrypted, even if there is a password
             set on the zip archive. 
             </para>
        <para>
             The zip spec does not describe how to encode the comment string in a code page other than IBM437. 
             Therefore, for "compliant" zip tools and libraries, comments will use IBM437.  However, there are
             situations where you want an encoded Comment, for example using code page 950 "Big-5 Chinese".
             DotNetZip will encode the comment in the code page specified by <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" />,
             at the time of the call to ZipFile.Save().
             </para>
        <para>
             When creating a zip archive using this library, it is possible to change the value of 
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each entry you add, and between adding entries and the 
             call to Save(). Don't do this.  It will likely result in a zipfile that is not readable by 
             any tool or application. 
             For best interoperability, leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or 
             specify it only once, before adding any entries to the ZipFile instance.
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Verbose">
      <summary>
            Indicates whether verbose output is sent to the StatusMessageWriter
            during <c>AddXxx()</c> and <c>ReadXxx()</c> operations. 
            </summary>
      <remarks>
            This is a synthetic property.  It returns true if the <see cref="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">StatusMessageTextWriter</see> is non-null. 
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval">
      <summary>
            Indicates whether to perform case-sensitive matching on the filename when retrieving
            entries in the zipfile via the string-based indexer.  
            </summary>
      <remarks>
            The default value is <c>false</c>,
            which means DON'T do case-sensitive matching. In other words, retrieving
            zip["ReadMe.Txt"] is the same as zip["readme.txt"].
            It really makes sense to set this to <c>true</c> only if you are not running on
            Windows, which has case-insensitive filenames. But since this library is not built for
            non-Windows platforms, in most cases you should just leave this property alone. 
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.UseUnicodeAsNecessary">
      <summary>
            Indicates whether to encode entry filenames and entry comments using Unicode 
            (UTF-8) according to the PKWare specification, for those filenames and comments
            that cannot be encoded in the IBM437 character set.
            </summary>
      <remarks>
        <para>
            The PKWare specification provides for encoding in either the IBM437 code page, or in UTF-8. 
            This flag selects the encoding according to that specification. 
            By default, this flag is false, and filenames and comments are encoded 
            into the zip file in the IBM437 codepage. 
            Setting this flag to true will specify that
            filenames and comments are encoded with UTF-8. 
            </para>
        <para>
            Zip files created with strict adherence to the PKWare specification
            with respect to UTF-8 encoding can contain entries with filenames containing
            any combination of Unicode characters, including the full 
            range of characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many 
            other alphabets. 
            However, because the UTF-8 portion of the PKWare specification is not broadly
            supported by other zip libraries and utilities, such zip files may not
            be readable by your favorite zip tool or archiver. In other words, interoperability
            will decrease if you set this flag to true. 
            </para>
        <para>
            In particular, Zip files created with strict adherence to the PKWare 
            specification with respect to UTF-8 encoding will not work well with 
            Explorer in Windows XP or Windows Vista, because Vista compressed folders 
            do not support UTF-8 in zip files.  Vista can read the zip files, but shows
            the filenames incorrectly.  Unpacking from Windows Vista Explorer will result in filenames
            that have rubbish characters in place of the high-order UTF-8 bytes.
            </para>
        <para>
            Also, zip files that use UTF-8 encoding will not work well 
            with Java applications that use the java.util.zip classes, as of 
            v5.0 of the Java runtime. The Java runtime does not correctly 
            implement the PKWare specification in this regard.
            </para>
        <para>
            As a result, we have the unfortunate situation that "correct" 
            behavior by the DotNetZip library with regard to Unicode during zip creation will result 
            in zip files that are readable by strictly compliant and current tools (for example the most 
            recent release of the commercial WinZip tool); but these zip files will
            not  be readable by various other tools or libraries, including Windows Explorer.
            </para>
        <para>
            The DotNetZip library can read and write zip files 
            with UTF8-encoded entries, according to the PKware spec.  If you use DotNetZip for both 
            creating and reading the zip file, and you use UTF-8, there will be no loss of information 
            in the filenames. For example, using a self-extractor created by this
            library will allow you to unpack files correctly with no loss of 
            information in the filenames. 
            </para>
        <para>
            Encoding filenames and comments using the IBM437 codepage, the default
            behavior, will cause loss of information on some filenames,
            but the resulting zipfile will
            be more interoperable with other utilities. As an example of the 
            loss of information, the o-tilde character will be down-coded to plain o. 
            Likewise, the O with a stroke through it, used in Danish and Norwegian,
            will be down-coded to plain o. Chinese characters cannot be represented
            in codepage IBM437; when using the default encoding, Chinese characters in 
            filenames will be represented as ?.  
            </para>
        <para>
            The loss of information associated to the use of the IBM437 encoding can lead to
            runtime errors. For example, using IBM437, any sequence of 4 Chinese characters will
            be encoded as ????.  If your application creates a ZipFile, then adds two files, each
            with names of four Chinese characters each, this will result in a duplicate filename
            exception.  In the case where you add a single file with a name containing four
            Chinese characters, calling Extract() on the entry that has question marks in the
            filename will result in an exception, because the question mark is not legal for use
            within filenames on Windows.  These are just a few examples of the problems associated
            to loss of information.
            </para>
        <para>
            This flag is independent of the encoding of the content within the 
            entries in the zip file.  
            </para>
        <para>
            Rather than specify the encoding in a binary fashion using this flag, an application
            can specify an arbitrary encoding via the <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property.  Setting 
            the encoding explicitly when creating zip archives will result in non-compliant 
            zip files that, curiously, are fairly interoperable.  The challenge is, the PKWare specification
            does not provide for a way to specify that an entry in a zip archive uses a code page that is
            neither IBM437 nor UTF-8.   Therefore 
            if you set the encoding explicitly when creating a zip archive, you must take care upon 
            reading the zip archive to use the same code page.  If you get it wrong, the behavior is 
            undefined and may result in incorrect filenames, exceptions, stomach upset, hair loss, and acne.  
            </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">ProvisionalAlternateEncoding</seealso>
    </member>
    <member name="P:Ionic.Zip.ZipFile.UseZip64WhenSaving">
      <summary>
             Specify whether to use ZIP64 extensions when saving a zip archive. 
             </summary>
      <remarks>
        <para>
             The original zip specification from PKWARE allowed for 32-bit quantities
             for the compressed and uncompressed sizes of files, as well as a 32-bit
             quantity for specifying the length of the zip archive itself, and a
             maximum number of entries of 65535.  These limits are now regularly
             exceeded in many backup and archival scenarios.  PKWare added extensions
             to the original zip spec, called "ZIP64 extensions", to raise those
             limitations.  This property governs whether the DotNetZip library will use those extensions
             when saving zip archives.
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.Always" /> to always use ZIP64 extensions, regardless of 
             whether your zip archive needs it.  Suppose you have 5 files, each under 100k.  If you 
             specify Always for this flag before zipping them up, you will get a zip64 archive, though 
             none of the original zip limits had been exceeded.
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.Never" /> to tell the DotNetZip library to never use
             ZIP64 extensions.  This is useful for maximum compatibility and interoperability, at the
             expense of the capability of handling large archives.  NB: Windows Explorer in Windows
             XP and Windows Vista cannot currently extract files from a zip64 archive, so if you want
             to always produce zip archives that work in Windows Explorer, use <c>Never</c>. If your 
             application creates a zip that would exceed one of the ZIP64 limits, the library will 
             throw  an exception.
             </para>
        <para>
             Set this property to <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> to tell the DotNetZip library to use
             the zip64 extensions when required by the entry. After the file is compressed, the
             original and compressed sizes are checked, and if they exceed the oxFFFFFFFF limits,
             then zip64 can be used. That is the general idea, but there is an additional wrinkle
             when saving to a non-seekable device, like the ASP.NET Response.Output stream, or
             Console.Out.  When using non-seekable devices for output, the entry header is emitted
             and must indicate whether zip64 is in use, before we know if zip64 is necessary.  By definition, 
             the library cannot seek backward on such a device, so the header can never be changed. 
             The use of ZIP64 extensions is final after the header is emitted.  Therefore, when saving
             to non-seekable devices, using <see cref="F:Ionic.Zip.Zip64Option.AsNecessary" /> is the same as using 
             <see cref="F:Ionic.Zip.Zip64Option.Always" />.
             </para>
        <para>
             The default value is <see cref="F:Ionic.Zip.Zip64Option.Never" />.
             </para>
        <para>
             There is no need to specify whether to use ZIP64 when reading an existing zip archive.
             The library will use ZIP64 if and when appropriate.
             </para>
        <para>
             Have you thought about donating? http://cheeso.members.winisp.net/DotNetZipDonate.aspx
             </para>
      </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding">
      <summary>
             The text encoding to use when writing new entries to the ZipFile, for those
             entries that cannot be encoded with the default (IBM437) encoding; or, the
             text encoding that was used when reading the entries from the ZipFile.
             </summary>
      <remarks>
        <para>
             In its AppNote.txt document, PKWare describes how to specify in the zip entry
             header that a filename or comment containing non-ANSI characters is encoded with
             UTF-8.  But, some archivers do not follow the specification, and instead encode
             super-ANSI characters using the system default code page.  For example, WinRAR
             when run on a machine in Shanghai may encode filenames with the Big-5 Chinese
             (950) code page.  This behavior is contrary to the Zip specification, but it
             occurs anyway.
             </para>
        <para>
             When using DotNetZip to write zip archives that will be read by one of these other
             archivers, set this property to specify the code page to use when encoding the <see cref="P:Ionic.Zip.ZipEntry.FileName" /> and <see cref="P:Ionic.Zip.ZipEntry.Comment" /> for each ZipEntry in the zip file,
             for values that cannot be encoded with the default codepage for zip files, IBM437.
             This is why this property is "provisional".  In all cases, IBM437 is used where
             possible, in other words, where no loss of data would result. It is possible, therefore, to have a given 
             entry with a Comment encoded in IBM437 and a FileName encoded with the specified "provisional" codepage. 
             </para>
        <para>
             Be aware that a zip file created after you've explicitly set the
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> property to a value other than IBM437 may not be compliant
             to the PKWare specification, and may not be readable by compliant archivers.  On
             the other hand, many (most?) archivers are non-compliant and can read zip files
             created in arbitrary code pages.  The trick is to use or specify the proper codepage when
             reading the zip.
             </para>
        <para>
             When creating a zip archive using this library, it is possible to change the value of 
             <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> between each entry you add, and between adding entries and the 
             call to Save(). Don't do this. It will likely result in a zipfile that is not readable. 
             For best interoperability, either leave <see cref="P:Ionic.Zip.ZipFile.ProvisionalAlternateEncoding" /> alone, or 
             specify it only once, before adding any entries to the ZipFile instance.  
             If you want to add a comment to the ZipFile, and you would the comment to be encoded 
             in a code page that is different than the code page you use for the filenames of the entries in the archive, 
             then you can specify ProvisionalAlternateEncoding once before adding entries and then 
             reset ProvisionalAlternateEncoding to IBM437 before calling Save().
             </para>
        <para>
             When using DotNetZip to read a zip archive that has been created by a different
             tool or library, and the zip archive uses an arbitrary code page, you must
             specify the encoding to use before or when the zipfile is READ.  This means you
             must use a ZipFile.Read() method that allows you to specify a
             System.Text.Encoding parameter.  Setting the ProvisionalAlternateEncoding property after
             your application has read in the zip archive will not affect the entry names of
             entries that have already been read in, and is probably not what you want.
             </para>
        <para>
             When using an arbitrary, non-UTF8 code page for encoding, there is no standard
             way for the creator application - whether DotNetZip, WinZip, WinRar, or something else -
             to specify in the zip file which codepage has been used for the entries. As a result, readers of
             zip files are not able to inspect the zip file and determine the codepage that
             was used for the entries contained within it.  It is left to the application to
             determine the necessary codepage when reading zipfiles encoded this way.  If you
             use an incorrect codepage when reading a zipfile, you will get entries with
             filenames that are incorrect, and the incorrect filenames may even contain characters that are not
             legal for use within filenames in Windows. Extracting entries with illegal
             characters in the filenames will lead to exceptions. It's too bad, but this is just the
             way things are with code pages in zip files. Caveat Emptor.
             </para>
      </remarks>
      <seealso cref="F:Ionic.Zip.ZipFile.DefaultEncoding">DefaultEncoding</seealso>
    </member>
    <member name="P:Ionic.Zip.ZipFile.StatusMessageTextWriter">
      <summary>
             Gets or sets the <c>TextWriter</c> to which status messages are delivered 
             for the instance. 
             </summary>
      <remarks>
             If the TextWriter is set to a non-null value, then 
             verbose output is sent to the <c>TextWriter</c> during <c>Add</c><c>, Read</c><c>, Save</c> and
             <c>Extract</c> operations.  Typically, console applications might use <c>Console.Out</c> and 
             graphical or headless applications might use a <c>System.IO.StringWriter</c>.
             </remarks>
      <example>
        <para>
             In this example, a console application instantiates a ZipFile, then sets
             the StatusMessageTextWriter to Console.Out.  At that point, all verbose
             status messages for that ZipFile are sent to the console. 
             </para>
        <code lang="C#">
             using (ZipFile zip= new ZipFile(FilePath))
             {
               zip.StatusMessageTextWriter= System.Console.Out;
               // messages are sent to the console during extraction
               zip.ExtractAll();
             }
             </code>
        <code lang="VB">
             Using zip As new ZipFile(FilePath)
               zip.StatusMessageTextWriter= System.Console.Out
               'Status Messages will be sent to the console during extraction
               zip.ExtractAll()
             End Using
             </code>
      </example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.ForceNoCompression">
      <summary>
             Gets or sets the flag that indicates whether the ZipFile should use
             compression for subsequently added entries in the ZipFile instance.
             </summary>
      <remarks>
        <para> 
             When saving an entry into a zip archive, the DotNetZip by default compresses
             the file. That's what a ZIP archive is all about, isn't it?  
             For files that are already compressed, like MP3's or JPGs,
             the deflate algorithm can actually slightly expand the size of the data.  Setting this
             property to trye allows you to specify that compression should not be used. 
             The default value is false.
             </para>
        <para>
             Do not construe setting this flag to false as "Force Compression".  Setting it
             to false merely does NOT force No compression.  
             If you want to force the use of the deflate algorithm when
             storing each entry into the zip archive, define a <see cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" /> callback, which always returns false, and a 
             <see cref="P:Ionic.Zip.ZipFile.WantCompression" /> callback that always returns true.  This is
             probably the wrong thing to do, but you could do it. Forcing the use of the
             Deflate algorithm when storing an entry does not guarantee that the data size
             will get smaller. It could increase, as described above.  
             </para>
        <para>
             Changes to this flag apply to all entries subsequently added to the archive. 
             The application can also set the <see cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
             property on each ZipEntry, for more granular control of this capability.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipEntry.CompressionMethod" />
      <seealso cref="P:Ionic.Zip.ZipFile.CompressionLevel" />
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
      <example>
             This example shows how to specify that Compression will not be used when adding files 
             to the zip archive. None of the files added to the archive in this example will use
             compression.
             <code>
             using (ZipFile zip = new ZipFile(ZipFileToCreate))
             {
               zip.ForceNoCompression = true;
               zip.AddDirectory(@"c:\temp\Foo");
               zip.Comment = "All files in this archive will be uncompressed.";
               zip.Save();
             }
             </code><code lang="VB">
             Using zip As New ZipFile(ZipFileToCreate)
               zip.ForceNoCompression = true
               zip.AddDirectory("c:\temp\Foo")
               zip.Comment = "All files in this archive will be uncompressed."
               zip.Save()
             End Using
             </code></example>
    </member>
    <member name="P:Ionic.Zip.ZipFile.TempFileFolder">
      <summary>
             Gets or sets the name for the folder to store the temporary file
             this library writes when saving a zip archive. 
             </summary>
      <remarks>
        <para>
             This library will create a temporary file when saving a Zip archive.
             By default, the library uses the value of <see cref="M:System.IO.Path.GetTempPath" />
             as the location in which to store temporary files. For some scenarios, such as ASP.NET
             applications, the application may wish to explicitly override this default behavior.
             </para>
        <para>
             The temporary file is written when calling one of the
             <c>Save()</c> methods, or the <c>SaveSelfExtractor()</c> method.
             </para>
        <para>
             The folder specified must exist; if it does not an exception is thrown.
             The application should have write and delete permissions on the folder. 
             The permissions are 
             never explicitly checked; if the application does not have the appropriate rights, an exception
             will be thrown at the time <c>Save()</c> is called. 
             </para>
        <para>
             There is no temporary file created when reading a zip archive. 
             When saving to a Stream, there is no temporary file created.  For example, if the application 
             is an ASP.NET application and calls <c>Save()</c> specifying the Response.OutStream as the output 
             stream, there is no temporary file created. 
             </para>
      </remarks>
      <exception cref="T:System.IO.FileNotFoundException">
             Thrown when setting the property if the directory does not exist. 
             </exception>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Password">
      <summary>
             Sets the password to be used on the ZipFile instance.
             </summary>
      <remarks>
        <para>
             When writing a zip archive, this password is applied to the entries, not
             to the zip archive itself. It applies to any ZipEntry subsequently added 
             to the ZipFile, using one of the AddFile, AddDirectory, or AddItem methods. 
             When reading a zip archive, this property applies to any entry subsequently 
             extracted from the ZipFile using one of the Extract methods on the ZipFile class.  
             </para>
        <para>
             When writing a zip archive, keep this in mind: though the password is set on the
             ZipFile object, according to the Zip spec, the "directory" of the archive - in
             other words the list of entries contained in the archive - is not encrypted with
             the password, or protected in any way.  IF you set the Password property, the
             password actually applies to individual entries that are added to the archive,
             subsequent to the setting of this property.  The list of filenames in the
             archive that is eventually created will appear in clear text, but the contents
             of the individual files are encrypted.  This is how Zip encryption works.
             </para>
        <para>
             If you set the password on the zip archive, and then add a set of files to the 
             archive, then each entry is encrypted with that password.  You may also want 
             to change the password between adding different entries. If you set the 
             password, add an entry, then set the password to null, and add another entry,
             the first entry is encrypted and the second is not.  Furshtay?
             </para>
        <para>
             When setting the Password, you may also want to explicitly set the <see cref="P:Ionic.Zip.ZipFile.Encryption" /> property, to specify how to encrypt the entries added to the
             ZipFile.  If you set the Password to a non-null value and do not set <see cref="P:Ionic.Zip.ZipFile.Encryption" />, then PKZip 2.0 ("Weak") encryption is used.  This
             encryption is relatively weak but is very interoperable. If you set the password
             to a null value (<c>Nothing</c> in VB), Encryption is reset to None.
             </para>
        <para>
             All of the preceding applies to writing zip archives - when you use one of the
             Save methods.  To use this property when reading or an existing ZipFile -
             calling Extract methods on the ZipFile or the ZipEntry instances - do the
             following: set the Password property, then call one of the ZipFile.Extract()
             overloads. In this case, the entry is extracted using the Password that is
             specified on the ZipFile instance. If you have not set the Password property,
             then the password is null, and the entry is extracted with no password.
             </para>
        <para>
             If you set Password on the ZipFile, then Extract() an entry that has not been 
             encrypted with a password, then the password is not used for that entry, and
             the ZipEntry is extracted as normal.
             </para>
      </remarks>
      <example>
        <para>
             In this example, three files are added to a Zip archive. The ReadMe.txt file
             will be placed in the root of the archive, and will not be encrypted. 
             The .png file will be included into the zip, encrypted with the "123456!" password.
             The pdf file will be included, encrypted with "!Secret1" as the password.
             </para>
        <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.AddFile("ReadMe.txt");
                    zip.Password= "123456!";
                    zip.AddFile("7440-N49th.png");
                    zip.Password= "!Secret1";
                    zip.AddFile("2005_Annual_Report.pdf");
            
                    zip.Save("EncryptedArchive.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: {0}", ex1);
                }
             </code>
        <code lang="VB">
              Try 
                Using zip As New ZipFile()
                  zip.AddFile("ReadMe.txt")
                  zip.Password = "123456!"
                  zip.AddFile("7440-N49th.png")
                  zip.Password= "!Secret1";
                  zip.AddFile("2005_Annual_Report.pdf")
                  zip.Save("EncryptedArchive.zip")
                End Using
              Catch ex1 As System.Exception
                System.Console.Error.WriteLine("exception: {0}", ex1)
              End Try
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.Encryption" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.Encryption">
      <summary>
             The Encryption to use for entries added to the ZipFile.
             </summary>
      <remarks>
        <para>
             The specified Encryption is applied to the entries subsequently added to the ZipFile instance.  
             </para>
        <para>
             If you set this to something other than EncryptionAlgorithm.None, you will also need to set 
             the <see cref="P:Ionic.Zip.ZipFile.Password" />.
             </para>
        <para>
             As with other properties (like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />),
             setting this property a ZipFile instance will cause that EncryptionAlgorithm to be used on
             all ZipEntry items that are subsequently added to the ZipFile instance. In other words, if
             you set this property after you have added items to the ZipFile, but before you have called
             Save(), those items will not be encrypted or protected with a password in the resulting zip
             archive. To get a zip archive with encrypted entries, set this property, along with the <see cref="P:Ionic.Zip.ZipFile.Password" />
             property, before calling <c>AddFile</c>, <c>AddItem</c>, or <c>AddDirectory</c> on the ZipFile instance.
             </para>
      </remarks>
      <example>
        <code>
                try
                {
                  using (ZipFile zip = new ZipFile())
                  {
                    zip.Encryption= EncryptionAlgorithm.WinZipAes256;
                    zip.Password= "Some.Like.It.Hot.1959!";
                    zip.AddFile("ReadMe.txt");
                    zip.AddFile("7440-N49th.png");
                    zip.AddFile("2005_Annual_Report.pdf");
                    zip.Save("EncryptedArchive.zip");
                  }
                }
                catch (System.Exception ex1)
                {
                  System.Console.Error.WriteLine("exception: {0}", ex1);
                }
             </code>
        <code lang="VB">
              Try 
                Using zip As New ZipFile()
                  zip.Encryption= EncryptionAlgorithm.WinZipAes256
                  zip.Password= "Some.Like.It.Hot.1959!"
                  zip.AddFile("ReadMe.txt")
                  zip.AddFile("7440-N49th.png")
                  zip.AddFile("2005_Annual_Report.pdf")
                  zip.Save("EncryptedArchive.zip")
                End Using
              Catch ex1 As System.Exception
                System.Console.Error.WriteLine("exception: {0}", ex1)
              End Try
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.Password" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation">
      <summary>
             A callback that allows the application to specify whether multiple reads of the
             stream should be performed, in the case that a compression operation actually
             inflates the size of the file data.  
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm in <c>DeflateStream</c> can
             result an increase in the size of the data.  This "inflation" can happen with
             previously compressed files, such as a zip, jpg, png, mp3, and so on.  In a few
             tests, inflation on zip files can be as large as 60%!  Inflation can also happen
             with very small files.  In these cases, by default, the DotNetZip library
             discards the compressed bytes, and stores the uncompressed file data into the
             zip archive.  This is an optimization where smaller size is preferred over
             longer run times.
             </para>
        <para>
             The application can specify that compression is not even tried, by setting the
             ForceNoCompression flag.  In this case, the compress-and-check-sizes process as
             decribed above, is not done.
             </para>
        <para>
             In some cases, neither choice is optimal.  The application wants compression,
             but in some cases also wants to avoid reading the stream more than once.  This
             may happen when the stream is very large, or when the read is very expensive, or
             when the difference between the compressed and uncompressed sizes is not
             significant.
             </para>
        <para>
             To satisfy these applications, this delegate allows the DotNetZip library to ask
             the application to for approval for re-reading the stream, in the case where
             inflation occurs.  The callback is invoked only in the case of inflation; that
             is to say when the uncompressed stream is smaller than the compressed stream.
             </para>
        <para>
             As with other properties (like <see cref="P:Ionic.Zip.ZipFile.Password" /> and <see cref="P:Ionic.Zip.ZipFile.ForceNoCompression" />),
             setting the corresponding delegate on a ZipFile instance will caused it to be applied to all ZipEntry
             items that are subsequently added to the ZipFile instance. In other words, if you set this
             callback after you have added files to the ZipFile, but before you have called Save(), those
             items will not be governed by the callback when you do call Save(). Your best bet is to 
             set this callback before adding any entries.  
             </para>
        <para>
             Of course, if you want to have different callbacks for different entries, you may do so. 
             </para>
      </remarks>
      <example>
        <para>
             In this example, the application callback checks to see if the difference
             between the compressed and uncompressed data is greater than 25%.  If it is,
             then the callback returns true, and the application tells the library to re-read
             the stream.  If not, then the callback returns false, and the library just keeps
             the "inflated" file data.
             </para>
        <code>
            
             public bool ReadTwiceCallback(long uncompressed, long compressed, string filename)
             {
                 return ((uncompressed * 1.0/compressed) &gt; 1.25);
             }
             
             public void CreateTheZip()
             {
                 using (ZipFile zip = new ZipFile())
                 {
                     // set the callback before adding files to the zip
                     zip2.WillReadTwiceOnInflation = ReadTwiceCallback;
                     zip2.AddFile(filename1);
                     zip2.AddFile(filename2);
                     zip2.Save(ZipFileToCreate);
                 }
             }
             </code>
      </example>
      <seealso cref="P:Ionic.Zip.ZipFile.WantCompression" />
      <seealso cref="T:Ionic.Zip.WantCompressionCallback" />
      <seealso cref="P:Ionic.Zip.ZipEntry.WillReadTwiceOnInflation" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.WantCompression">
      <summary>
             A callback that allows the application to specify whether compression should
             be used for entries subsequently added to the zip archive.
             </summary>
      <remarks>
        <para>
             In some cases, applying the Deflate compression algorithm to an entry *may*
             result a slight increase in the size of the data.  This "inflation" can
             happen with previously compressed files, such as a zip, jpg, png, mp3, and
             so on; it results from adding DEFLATE framing data around incompressible data.
             Inflation can also happen with very small files. Applications may wish to
             avoid the use of compression in these cases. As well, applications may wish
             to avoid compression to save time.
             </para>
        <para>
             By default, the DotNetZip library takes this approach to decide whether to
             apply compression: first it applies a heuristic, to determine whether it
             should try to compress a file or not.  The library checks the extension of
             the entry, and if it is one of a known list of uncompressible file types
             (mp3, zip, docx, and others), the library will not attempt to compress the
             entry.  The library does not actually check the content of the entry.  If
             you name a text file "Text.mp3", and then attempt to add it to a zip
             archive, this library will, by default, not attempt to compress the entry,
             based on the extension of the filename.
             </para>
        <para>
             If this default behavior is not satisfactory, there are two options. First,
             the application can override it by setting this <see cref="P:Ionic.Zip.ZipFile.WantCompression" /> callback.  This affords maximum control to
             the application.  With this callback, the application can supply its own
             logic for determining whether to apply the Deflate algorithm or not.  For
             example, an application may desire that files over 40mb in size are never
             compressed, or always compressed.  An application may desire that the first
             7 entries added to an archive are compressed, and the remaining ones are
             not.  The WantCompression callback allows the application full control, on
             an entry-by-entry basis.
             </para>
        <para>
             The second option for overriding the default logic regarding whether to
             apply compression is the ForceNoCompression flag.  If this flag is set to
             true, the compress-and-check-sizes process as decribed above, is not done,
             nor is the callback invoked.  In other words, if you set ForceNoCompression
             to true, andalso set the WantCompression callback, only the
             ForceNoCompression flag is considered.
             </para>
        <para>
             This is how the library determines whether compression will be attempted for 
             an entry.  If it is to be attempted, the library reads the entry, runs it through
             the deflate algorithm, and then checks the size of the result.  If applying
             the Deflate algorithm increases the size of the data, then the library
             discards the compressed bytes, re-reads the raw entry data, and stores the
             uncompressed file data into the zip archive, in compliance with the zip
             spec.  This is an optimization where smaller size is preferred over longer
             run times. The re-reading is gated on the <see cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" /> callback, if it is set. This callback applies
             independently of the WantCompression callback.
             </para>
        <para>
             If by the logic described above, compression is not to be attempted for an entry, 
             the library reads the entry, and simply stores the entry data uncompressed. 
             </para>
        <para>
             And, if you have read this far, I would like to point out that a single
             person wrote all the code that does what is described above, and also wrote
             the description.  Isn't it about time you donated $5 in appreciation?  The
             money goes to a charity. See
             http://cheeso.members.winisp.net/DotNetZipDonate.aspx.
             </para>
      </remarks>
      <seealso cref="P:Ionic.Zip.ZipFile.WillReadTwiceOnInflation" />
    </member>
    <member name="P:Ionic.Zip.ZipFile.LibraryVersion">
      <summary>
            Returns the version number on the DotNetZip assembly.
            </summary>
      <remarks>
            This property is exposed as a convenience.  Callers
            could also get the version value by retrieving  GetName().Version 
            on the System.Reflection.Assembly object pointing to the
            DotNetZip assembly. But sometimes it is not clear which
            assembly is being loaded.  This property makes it clear. 
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Item(System.Int32)">
      <summary>
             This is an integer indexer into the Zip archive.
             </summary>
      <remarks>
        <para>
             This property is read-write. But don't get too excited: When setting the value, the
             only legal value is null. If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
        <para>
             Setting the value to null is equivalent to calling <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
             with the filename for the given entry.
             </para>
      </remarks>
      <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer, 
             or if the caller uses an out-of-range index value.
             </exception>
      <param name="ix">
             The index value.
             </param>
      <returns>
             The ZipEntry within the Zip archive at the specified index. If the 
             entry does not exist in the archive, this indexer throws.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Item(System.String)">
      <summary>
             This is a name-based indexer into the Zip archive.  
             </summary>
      <remarks>
        <para>
             Retrieval by the string-based indexer is done on a case-insensitive basis, 
             by default.  Set the <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to use case-sensitive 
             comparisons. 
             </para>
        <para>
             This property is read-write. When setting the value, the
             only legal value is null. Setting the value to null is
             equivalent to calling <see cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" /> with the filename.
             </para>
        <para>
             If you assign a non-null value
             (non Nothing in VB), the setter will throw an exception.
             </para>
        <para>
             It is not always the case that <c>this[value].FileName == value</c>.  In
             the case of directory entries in the archive, you may retrieve them with
             the name of the directory with no trailing slash, even though in the
             entry itself, the actual <see cref="P:Ionic.Zip.ZipEntry.FileName" /> property may
             include a trailing slash.  In other words, for a directory entry named
             "dir1", you may find <c>this["dir1"].FileName == "dir1/"</c>.
             </para>
      </remarks>
      <example>
             This example extracts only the entries in a zip file that are .txt files.
             <code>
             using (ZipFile zip = ZipFile.Read("PackedDocuments.zip"))
             {
               foreach (string s1 in zip.EntryFilenames)
               {
                 if (s1.EndsWith(".txt"))
                   zip[s1].Extract("textfiles");
               }
             }
             </code><code lang="VB">
               Using zip As ZipFile = ZipFile.Read("PackedDocuments.zip")
                   Dim s1 As String
                   For Each s1 In zip.EntryFilenames
                       If s1.EndsWith(".txt") Then
                           zip(s1).Extract("textfiles")
                       End If
                   Next
               End Using
             </code></example>
      <seealso cref="M:Ionic.Zip.ZipFile.RemoveEntry(System.String)" />
      <exception cref="T:System.ArgumentException">
             Thrown if the caller attempts to assign a non-null value to the indexer.
             </exception>
      <param name="fileName">
             The name of the file, including any directory path, to retrieve from the zip. 
             The filename match is not case-sensitive by default; you can use the
             <see cref="P:Ionic.Zip.ZipFile.CaseSensitiveRetrieval" /> property to change this behavior. The
             pathname can use forward-slashes or backward slashes.
             </param>
      <returns>
             The ZipEntry within the Zip archive, given by the specified filename. If the named
             entry does not exist in the archive, this indexer returns null.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.EntryFileNames">
      <summary>
             The list of filenames for the entries contained within the zip archive.  The 
             filenames use forward slashes in pathnames. 
             </summary>
      <seealso cref="P:Ionic.Zip.ZipFile.Item(System.String)" />
      <example>
             This example shows one way to test if a filename is already contained within 
             a zip archive.
             <code>
             String ZipFileToRead= "PackedDocuments.zip";
             string Candidate = "DatedMaterial.xps";
             using (ZipFile zip = new ZipFile(ZipFileToRead))
             {
               if (zip.EntryFilenames.Contains(Candidate))
                 Console.WriteLine("The file '{0}' exists in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               else
                 Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'",
                                   Candidate,
                                   ZipFileName);
               Console.WriteLine();
             }
             </code><code lang="VB">
               Dim ZipFileToRead As String = "PackedDocuments.zip"
               Dim Candidate As String = "DatedMaterial.xps"
               Using zip As New ZipFile(ZipFileToRead)
                   If zip.EntryFilenames.Contains(Candidate) Then
                       Console.WriteLine("The file '{0}' exists in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   Else
                     Console.WriteLine("The file, '{0}', does not exist in the zip archive '{1}'", _
                                   Candidate, _
                                   ZipFileName)
                   End If
                   Console.WriteLine
               End Using
             </code></example>
      <returns>
             The list of strings for the filenames contained within the Zip archive.
             </returns>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Entries">
      <summary>
            Returns the readonly collection of entries in the Zip archive.
            </summary>
      <remarks>
            If there are no entries in the current ZipFile, the value returned is a non-null zero-element collection.
            </remarks>
    </member>
    <member name="P:Ionic.Zip.ZipFile.Count">
      <summary>
            Returns the number of entries in the Zip archive.
            </summary>
    </member>
    <member name="E:Ionic.Zip.ZipFile.SaveProgress">
      <summary>
             An event handler invoked when a Save() starts, before and after each entry has been
             written to the archive, when a Save() completes, and during other Save events.
             </summary>
      <remarks>
        <para>
             Depending on the particular event, different properties on the
             SaveProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a SaveProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Saving_Started</term>
            <description>Fired when ZipFile.Save() begins. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BeforeSaveEntry</term>
            <description>Fired within ZipFile.Save(), just before writing data for each particular entry. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterSaveEntry</term>
            <description>Fired within ZipFile.Save(), just after having finished writing data for each 
             particular entry. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_Completed</term>
            <description>Fired when ZipFile.Save() has completed. 
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterSaveTempArchive</term>
            <description>Fired after the temporary file has been created.  This happens only
             when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BeforeRenameTempArchive</term>
            <description>Fired just before renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterRenameTempArchive</term>
            <description>Fired just after renaming the temporary file to the permanent location.  This 
             happens only when saving to a disk file.  This event will not be invoked when saving to a stream.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_AfterCompileSelfExtractor</term>
            <description>Fired after a self-extracting archive has finished compiling. 
             This EventType is used only within SaveSelfExtractor().
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Saving_BytesRead</term>
            <description>Set during the save of a particular entry, to update progress of the Save(). 
             When this EventType is set, the BytesTransferred is the number of bytes that have been read from the 
             source stream.  The TotalBytesToTransfer is the number of bytes in the uncompressed file.
             </description>
          </item>
        </list>
      </remarks>
      <example>
        <code lang="C#">
             static bool justHadByteUpdate= false;
             public static void SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 if (e.EventType == ZipProgressEventType.Saving_Started)
                     Console.WriteLine("Saving: {0}", e.ArchiveName);
             
                 else if (e.EventType == ZipProgressEventType.Saving_Completed)
                 {
                     justHadByteUpdate= false; 
                     Console.WriteLine();
                     Console.WriteLine("Done: {0}", e.ArchiveName);
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_BeforeWriteEntry)
                 {
                     if (justHadByteUpdate) 
                         Console.WriteLine();
                     Console.WriteLine("  Writing: {0} ({1}/{2})",  
                                       e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal);
                     justHadByteUpdate= false;
                 }
             
                 else if (e.EventType == ZipProgressEventType.Saving_EntryBytesWritten)
                 {
                     if (justHadByteUpdate)
                         Console.SetCursorPosition(0, Console.CursorTop);
                      Console.Write("     {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite,
                                   e.BytesWritten / (0.01 * e.TotalBytesToWrite ));
                     justHadByteUpdate= true;
                 }
             }
             
             public static ZipUp(string targetZip, string directory)
             {
               using (var zip = new ZipFile()) {
                 zip.SaveProgress += SaveProgress; 
                 zip.AddDirectory(directory);
                 zip.Save(targetZip);
               }
             }
            
             </code>
        <para>
             This is an example of using the SaveProgress events in a WinForms app.
             </para>
        <code>
             delegate void SaveEntryProgress(SaveProgressEventArgs e);
             delegate void ButtonClick(object sender, EventArgs e);
            
             public class WorkerOptions
             {
                 public string ZipName;
                 public string Folder;
                 public string Encoding;
                 public string Comment;
                 public int ZipFlavor;
                 public Zip64Option Zip64;
             }
            
             private int _progress2MaxFactor;
             private bool _saveCanceled;
             private long _totalBytesBeforeCompress;
             private long _totalBytesAfterCompress;
             private Thread _workerThread;
            
            
             private void btnZipup_Click(object sender, EventArgs e)
             {
                 KickoffZipup();
             }
            
             private void btnCancel_Click(object sender, EventArgs e)
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new ButtonClick(this.btnCancel_Click), new object[] { sender, e });
                 }
                 else
                 {
                     _saveCanceled = true;
                     lblStatus.Text = "Canceled...";
                     ResetState();
                 }
             }
            
             private void KickoffZipup()
             {
                 _folderName = tbDirName.Text;
            
                 if (_folderName == null || _folderName == "") return;
                 if (this.tbZipName.Text == null || this.tbZipName.Text == "") return;
            
                 // check for existence of the zip file:
                 if (System.IO.File.Exists(this.tbZipName.Text))
                 {
                     var dlgResult = MessageBox.Show(String.Format("The file you have specified ({0}) already exists." + 
                                                                   "  Do you want to overwrite this file?", this.tbZipName.Text), 
                                                     "Confirmation is Required", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                     if (dlgResult != DialogResult.Yes) return;
                     System.IO.File.Delete(this.tbZipName.Text);
                 }
            
                  _saveCanceled = false;
                 _nFilesCompleted = 0;
                 _totalBytesAfterCompress = 0;
                 _totalBytesBeforeCompress = 0;
                 this.btnOk.Enabled = false;
                 this.btnOk.Text = "Zipping...";
                 this.btnCancel.Enabled = true;
                 lblStatus.Text = "Zipping...";
            
                 var options = new WorkerOptions
                 {
                     ZipName = this.tbZipName.Text,
                     Folder = _folderName,
                     Encoding = "ibm437"
                 };
            
                 if (this.comboBox1.SelectedIndex != 0)
                 {
                     options.Encoding = this.comboBox1.SelectedItem.ToString();
                 }
            
                 if (this.radioFlavorSfxCmd.Checked)
                     options.ZipFlavor = 2;
                 else if (this.radioFlavorSfxGui.Checked)
                     options.ZipFlavor = 1;
                 else options.ZipFlavor = 0;
            
                 if (this.radioZip64AsNecessary.Checked)
                     options.Zip64 = Zip64Option.AsNecessary;
                 else if (this.radioZip64Always.Checked)
                     options.Zip64 = Zip64Option.Always;
                 else options.Zip64 = Zip64Option.Never;
            
                 options.Comment = String.Format("Encoding:{0} || Flavor:{1} || ZIP64:{2}\r\nCreated at {3} || {4}\r\n",
                             options.Encoding,
                             FlavorToString(options.ZipFlavor),
                             options.Zip64.ToString(),
                             System.DateTime.Now.ToString("yyyy-MMM-dd HH:mm:ss"),
                             this.Text);
            
                 if (this.tbComment.Text != TB_COMMENT_NOTE)
                     options.Comment += this.tbComment.Text;
            
                 _workerThread = new Thread(this.DoSave);
                 _workerThread.Name = "Zip Saver thread";
                 _workerThread.Start(options);
                 this.Cursor = Cursors.WaitCursor;
              }
            
            
             private void DoSave(Object p)
             {
                 WorkerOptions options = p as WorkerOptions;
                 try
                 {
                     using (var zip1 = new ZipFile())
                     {
                         zip1.ProvisionalAlternateEncoding = System.Text.Encoding.GetEncoding(options.Encoding);
                         zip1.Comment = options.Comment;
                         zip1.AddDirectory(options.Folder);
                         _entriesToZip = zip1.EntryFileNames.Count;
                         SetProgressBars();
                         zip1.SaveProgress += this.zip1_SaveProgress;
            
                         zip1.UseZip64WhenSaving = options.Zip64;
            
                         if (options.ZipFlavor == 1)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.WinFormsApplication);
                         else if (options.ZipFlavor == 2)
                             zip1.SaveSelfExtractor(options.ZipName, SelfExtractorFlavor.ConsoleApplication);
                         else
                             zip1.Save(options.ZipName);
                     }
                 }
                 catch (System.Exception exc1)
                 {
                     MessageBox.Show(String.Format("Exception while zipping: {0}", exc1.Message));
                     btnCancel_Click(null, null);
                 }
             }
            
            
            
             void zip1_SaveProgress(object sender, SaveProgressEventArgs e)
             {
                 switch (e.EventType)
                 {
                     case ZipProgressEventType.Saving_AfterWriteEntry:
                         StepArchiveProgress(e);
                         break;
                     case ZipProgressEventType.Saving_EntryBytesRead:
                         StepEntryProgress(e);
                         break;
                     case ZipProgressEventType.Saving_Completed:
                         SaveCompleted();
                         break;
                     case ZipProgressEventType.Saving_AfterSaveTempArchive:
                         // this event only occurs when saving an SFX file
                         TempArchiveSaved();
                         break;
                 }
                 if (_saveCanceled)
                     e.Cancel = true;
             }
            
            
            
             private void StepArchiveProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar1.InvokeRequired)
                 {
                     this.progressBar1.Invoke(new SaveEntryProgress(this.StepArchiveProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         _nFilesCompleted++;
                         this.progressBar1.PerformStep();
                         _totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
                         _totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;
            
                         // reset the progress bar for the entry:
                         this.progressBar2.Value = this.progressBar2.Maximum = 1;
            
                         this.Update();
                     }
                 }
             }
            
            
             private void StepEntryProgress(SaveProgressEventArgs e)
             {
                 if (this.progressBar2.InvokeRequired)
                 {
                     this.progressBar2.Invoke(new SaveEntryProgress(this.StepEntryProgress), new object[] { e });
                 }
                 else
                 {
                     if (!_saveCanceled)
                     {
                         if (this.progressBar2.Maximum == 1)
                         {
                             // reset
                             Int64 max = e.TotalBytesToTransfer;
                             _progress2MaxFactor = 0;
                             while (max &gt; System.Int32.MaxValue)
                             {
                                 max /= 2;
                                 _progress2MaxFactor++;
                             }
                             this.progressBar2.Maximum = (int)max;
                             lblStatus.Text = String.Format("{0} of {1} files...({2})",
                                 _nFilesCompleted + 1, _entriesToZip, e.CurrentEntry.FileName);
                         }
            
                          int xferred = e.BytesTransferred &gt;&gt; _progress2MaxFactor;
            
                          this.progressBar2.Value = (xferred &gt;= this.progressBar2.Maximum)
                             ? this.progressBar2.Maximum
                             : xferred;
            
                          this.Update();
                     }
                 }
             }
            
             private void SaveCompleted()
             {
                 if (this.lblStatus.InvokeRequired)
                 {
                     this.lblStatus.Invoke(new MethodInvoker(this.SaveCompleted));
                 }
                 else
                 {
                     lblStatus.Text = String.Format("Done, Compressed {0} files, {1:N0}% of original.",
                         _nFilesCompleted, (100.00 * _totalBytesAfterCompress) / _totalBytesBeforeCompress);
                      ResetState();
                 }
             }
            
             private void ResetState()
             {
                 this.btnCancel.Enabled = false;
                 this.btnOk.Enabled = true;
                 this.btnOk.Text = "Zip it!";
                 this.progressBar1.Value = 0;
                 this.progressBar2.Value = 0;
                 this.Cursor = Cursors.Default;
                 if (!_workerThread.IsAlive)
                     _workerThread.Join();
             }
             </code>
        <code lang="VB">
             Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
             	Try 
             	    Using zip As ZipFile = New ZipFile
             		AddHandler zip.SaveProgress, AddressOf MySaveProgress
             		zip.AddDirectory(directory)
             		zip.Save(targetZip)
             	    End Using
             	Catch ex1 As Exception
             	    Console.Error.WriteLine(("exception: " &amp; ex1.ToString))
             	End Try
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Saving_Started) Then
                     Console.WriteLine("Saving: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_Completed) Then
                     CreateLargeZip.justHadByteUpdate = False
                     Console.WriteLine
                     Console.WriteLine("Done: {0}", e.ArchiveName)
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_BeforeWriteEntry) Then
                     If CreateLargeZip.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("  Writing: {0} ({1}/{2})", e.NameOfLatestEntry, e.EntriesSaved, e.EntriesTotal)
                     CreateLargeZip.justHadByteUpdate = False
             
                 ElseIf (e.EventType Is ZipProgressEventType.Saving_EntryBytesWritten) Then
                     If CreateLargeZip.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("     {0}/{1} ({2:N0}%)", e.BytesWritten, _
                                   e.TotalBytesToWrite, _
                                   (CDbl(e.BytesWritten) / (0.01 * e.TotalBytesToWrite)))
                     CreateLargeZip.justHadByteUpdate = True
                 End If
             End Sub
             </code>
      </example>
    </member>
    <member name="E:Ionic.Zip.ZipFile.ReadProgress">
      <summary>
             An event handler invoked before, during, and after the reading of a zip archive.
             </summary>
      <remarks>
        <para>
             Depending on the particular event being signaled, different properties on the
             ReadProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ReadProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Reading_Started</term>
            <description>Fired just as ZipFile.Read() begins. Meaningful properties: ArchiveName.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_Completed</term>
            <description>Fired when ZipFile.Read() has completed. Meaningful properties: ArchiveName.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_ArchiveBytesRead</term>
            <description>Fired while reading, updates the number of bytes read for the entire archive. 
             Meaningful properties: ArchiveName, NameOfLatestEntry, BytesTransferred, TotalBytesToTransfer.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_BeforeReadEntry</term>
            <description>Indicates an entry is about to be read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Reading_AfterReadEntry</term>
            <description>Indicates an entry has just been read from the archive.
             Meaningful properties: ArchiveName, EntriesTotal, NameOfLatestEntry.
             </description>
          </item>
        </list>
      </remarks>
    </member>
    <member name="E:Ionic.Zip.ZipFile.ExtractProgress">
      <summary>
             An event handler invoked before, during, and after extraction of entries 
             in the zip archive. 
             </summary>
      <remarks>
        <para>
             Depending on the particular event, different properties on the
             ExtractProgressEventArgs parameter are set.  The following table 
             summarizes the available EventTypes and the conditions under which this 
             event handler is invoked with a ExtractProgressEventArgs with the given EventType.
             </para>
        <list type="table">
          <listheader>
            <term>value of EntryType</term>
            <description>Meaning and conditions</description>
          </listheader>
          <item>
            <term>ZipProgressEventType.Extracting_BeforeExtractAll</term>
            <description>Set when ExtractAll() begins.  The ArchiveName, Overwrite,
             and ExtractLocation properties are meaningful.</description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_AfterExtractAll</term>
            <description>Set when ExtractAll() has completed.  The ArchiveName, 
             Overwrite, and ExtractLocation properties are meaningful.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_BeforeExtractEntry</term>
            <description>Set when an Extract() on an entry in the ZipFile has begun.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, NameOfLatestEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_AfterExtractEntry</term>
            <description>Set when an Extract() on an entry in the ZipFile has completed.  
             Properties that are meaningful:  ArchiveName, EntriesTotal, NameOfLatestEntry, Overwrite, 
             ExtractLocation, EntriesExtracted.
             </description>
          </item>
          <item>
            <term>ZipProgressEventType.Extracting_EntryBytesWritten</term>
            <description>Set within a call to Extract() on an entry in the ZipFile, as
             data is extracted for the entry.  Properties that are meaningful:  ArchiveName, 
             NameOfLatestEntry, BytesWritten, TotalBytesToWrite. 
             </description>
          </item>
        </list>
      </remarks>
      <example>
        <code>
             private static bool justHadByteUpdate = false;
             public static void ExtractProgress(object sender, ExtractProgressEventArgs e)
             {
               if(e.EventType == ZipProgressEventType.Extracting_EntryBytesWritten)
               {
                 if (justHadByteUpdate)
                   Console.SetCursorPosition(0, Console.CursorTop);
            
                 Console.Write("   {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite,
                               e.BytesWritten / (0.01 * e.TotalBytesToWrite ));
                 justHadByteUpdate = true;
               }
               else if(e.EventType == ZipProgressEventType.Extracting_BeforeExtractEntry)
               {
                 if (justHadByteUpdate) 
                   Console.WriteLine();
                 Console.WriteLine("Extracting: {0}", e.NameOfLatestEntry);
                 justHadByteUpdate= false;
               }
             }
            
             public static ExtractZip(string zipToExtract, string directory)
             {
               string TargetDirectory= "extract";
               using (var zip = ZipFile.Read(zipToExtract)) {
                 zip.ExtractProgress += ExtractProgress; 
                 foreach (var e in zip1)
                 {
                   e.Extract(TargetDirectory, true);
                 }
               }
             }
            
             </code>
        <code lang="VB">
             Public Shared Sub Main(ByVal args As String())
                 Dim ZipToUnpack As String = "C1P3SML.zip"
                 Dim TargetDir As String = "ExtractTest_Extract"
                 Console.WriteLine("Extracting file {0} to {1}", ZipToUnpack, TargetDir)
                 Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)
                     AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress
                     Dim e As ZipEntry
                     For Each e In zip1
                         e.Extract(TargetDir, True)
                     Next
                 End Using
             End Sub
             
             Private Shared justHadByteUpdate As Boolean = False
             
             Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)
                 If (e.EventType Is ZipProgressEventType.Extracting_EntryBytesWritten) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.SetCursorPosition(0, Console.CursorTop)
                     End If
                     Console.Write("   {0}/{1} ({2:N0}%)", e.BytesWritten, e.TotalBytesToWrite, (CDbl(e.BytesWritten) / (0.01 * e.TotalBytesToWrite)))
                     ExtractTest.justHadByteUpdate = True
                 ElseIf (e.EventType Is ZipProgressEventType.Extracting_BeforeExtractEntry) Then
                     If ExtractTest.justHadByteUpdate Then
                         Console.WriteLine
                     End If
                     Console.WriteLine("Extracting: {0}", e.NameOfLatestEntry)
                     ExtractTest.justHadByteUpdate = False
                 End If
             End Sub
             </code>
      </example>
    </member>
    <member name="T:Ionic.Zip.Zip64Option">
      <summary>
            Options for using ZIP64 extensions when saving zip archives. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Default">
      <summary>
            The default behavior, which is "Never".
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Never">
      <summary>
            Do not use ZIP64 extensions when writing zip archives.
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.AsNecessary">
      <summary>
            Use ZIP64 extensions when writing zip archives, as necessary. 
            For example, when a single entry exceeds 0xFFFFFFFF in size, or when the archive as a whole 
            exceeds 0xFFFFFFFF in size, or when there are more than 65535 entries in an archive.
            </summary>
    </member>
    <member name="F:Ionic.Zip.Zip64Option.Always">
      <summary>
            Always use ZIP64 extensions when writing zip archives, even when unnecessary.
            </summary>
    </member>
    <member name="T:Ionic.Zip.SelfExtractorFlavor">
      <summary>
            An enum that provides the different self-extractor flavors
            </summary>
    </member>
    <member name="F:Ionic.Zip.SelfExtractorFlavor.ConsoleApplication">
      <summary>
            A self-extracting zip archive that runs from the console or command line. 
            </summary>
    </member>
    <member name="F:Ionic.Zip.SelfExtractorFlavor.WinFormsApplication">
      <summary>
            A self-extracting zip archive that presents a graphical user interface when it is executed.. 
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionLevel">
      <summary>
            The compression level to be used when using a DeflateStream or ZlibStream with CompressionMode.Compress.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.NONE">
      <summary>
            NONE means that the data will be simply stored, with no change at all.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL0_NONE">
      <summary>
            Same as NONE.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.BEST_SPEED">
      <summary>
            The fastest but least effective compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL1_BEST_SPEED">
      <summary>
            A synonym for BEST_SPEED.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL2">
      <summary>
            A little slower, but better, than level 1.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL3">
      <summary>
            A little slower, but better, than level 2.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL4">
      <summary>
            A little slower, but better, than level 3.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL5">
      <summary>
            A little slower, but better, than level 4.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.DEFAULT">
      <summary>
            The default compression level.  Do these levels even matter?  Do people even care?  
            I have never measured the speed difference.  
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL6_DEFAULT">
      <summary>
            A synonym for DEFAULT.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL7">
      <summary>
            Pretty good compression!
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL8">
      <summary>
             Still better compression!
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.BEST_COMPRESSION">
      <summary>
            The "best" compression, where best means greatest reduction in size of the input data stream. 
            This is also the slowest compression.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionLevel.LEVEL9_BEST_COMPRESSION">
      <summary>
            A synonym for BEST_COMPRESSION.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionStrategy">
      <summary>
            I honestly don't know what this means, but it is possible to set it in the SetDeflateParameters() call.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.DEFAULT">
      <summary>
            It's probably safest to just leave this alone, or select the default. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.FILTERED">
      <summary>
            I don't know what this does. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionStrategy.HUFFMAN_ONLY">
      <summary>
            I don't know what this setting does either.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.CompressionMode">
      <summary>
            An enum to specify the direction of transcoding - whether to compress or decompress.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionMode.Compress">
      <summary>
            Used to specify that the stream should compress the data.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.CompressionMode.Decompress">
      <summary>
            Used to specify that the stream should decompress the data.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.ZlibException">
      <summary>
            A general purpose exception class for exceptions in the Zlib library.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibException.#ctor">
      <summary>
            The ZlibException class captures exception information generated
            by the Zlib library. 
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibException.#ctor(System.String)">
      <summary>
            This ctor collects a message attached to the exception.
            </summary>
      <param name="s">
      </param>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int32)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int32,System.Int64)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int64,System.Int32)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.URShift(System.Int64,System.Int64)">
      <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
      <param name="number">Number to operate on</param>
      <param name="bits">Ammount of bits to shift</param>
      <returns>The resulting number from the shift operation</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
      <param name="sourceStream">The source Stream to read from.</param>
      <param name="target">Contains the array of characteres read from the source Stream.</param>
      <param name="start">The starting index of the target array.</param>
      <param name="count">The maximum number of characters to read from the source Stream.</param>
      <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the end of the stream is reached.</returns>
    </member>
    <member name="M:Ionic.Zlib.SharedUtils.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
      <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
      <param name="sourceTextReader">The source TextReader to read from</param>
      <param name="target">Contains the array of characteres read from the source TextReader.</param>
      <param name="start">The starting index of the target array.</param>
      <param name="count">The maximum number of characters to read from the source TextReader.</param>
      <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
    </member>
    <member name="T:Ionic.Zlib.Adler">
      <summary>
            Computes an Adler-32 checksum. 
            </summary>
      <remarks>
            The Adler checksum is similar to a CRC checksum, but faster to compute, though less reliable.  
            It is used in producing RFC1950 compressed streams.  The Adler checksum is a required part of the "ZLIB" standard.
            Applications will almost never need to use this class directly. 
            </remarks>
    </member>
    <member name="T:Ionic.Zlib.ZlibCodec">
      <summary>
            Encoder and Decoder for ZLIB (IETF RFC1950 and RFC1951).
            </summary>
      <remarks>
            This class compresses and decompresses data according to the Deflate algorithm documented in RFC1950 and RFC1951. 
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.InputBuffer">
      <summary>
            The buffer from which data is taken.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.NextIn">
      <summary>
            An index into the InputBuffer array, indicating where to start reading. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesIn">
      <summary>
            The number of bytes available in the InputBuffer, starting at NextIn. 
            </summary>
      <remarks>
            Generally you should set this to InputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesIn">
      <summary>
            Total number of bytes read so far, through all calls to Inflate()/Deflate().
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.OutputBuffer">
      <summary>
            Buffer to store output data.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.NextOut">
      <summary>
            An index into the OutputBuffer array, indicating where to start writing. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.AvailableBytesOut">
      <summary>
            The number of bytes available in the OutputBuffer, starting at NextOut. 
            </summary>
      <remarks>
            Generally you should set this to OutputBuffer.Length before the first Inflate() or Deflate() call. 
            The class will update this number as calls to Inflate/Deflate are made.
            </remarks>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.TotalBytesOut">
      <summary>
            Total number of bytes written to the output so far, through all calls to Inflate()/Deflate().
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibCodec.Message">
      <summary>
            used for diagnostics, when something goes wrong!
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.#ctor">
      <summary>
            Create a ZlibCodec.
            </summary>
      <remarks>
            If you use this default constructor, you will later have to explicitly call 
            InitializeInflate() or InitializeDeflate() before using the ZlibCodec to compress 
            or decompress. 
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.#ctor(Ionic.Zlib.CompressionMode)">
      <summary>
            Create a ZlibCodec that either compresses or decompresses.
            </summary>
      <param name="mode">
            Indicates whether the codec should compress (deflate) or decompress (inflate).
            </param>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate">
      <summary>
            Initialize the inflation state. 
            </summary>
      <remarks>
            It is not necessary to call this before using the ZlibCodec to inflate data; 
            It is implicitly called when you call the constructor.
            </remarks>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Boolean)">
      <summary>
            Initialize the inflation state with an explicit flag to govern the handling of RFC1950 header bytes. 
            </summary>
      <remarks>
            By default, the RFC1950 header is expected.  If you want to read a zlib stream 
            you should specify true for expectRfc1950Header.  If you have a deflate stream, you will
            want to specify false. It is only necessary to invoke this initializer explicitly if you want 
            to specify false.
            </remarks>
      <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading the stream of data to be inflated.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32)">
      <summary>
            Initialize the ZlibCodec for inflation, with the specified number of window bits. 
            </summary>
      <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeInflate(System.Int32,System.Boolean)">
      <summary>
            Initialize the inflation state with an explicit flag to govern the handling of RFC1950 header bytes. 
            </summary>
      <remarks>
            If you want to read a zlib stream 
            you should specify true for expectRfc1950Header.  If you have a deflate stream, you will
            want to specify false. 
            </remarks>
      <param name="expectRfc1950Header">whether to expect an RFC1950 header byte pair when reading 
            the stream of data to be inflated.</param>
      <param name="windowBits">The number of window bits to use. If you need to ask what that is, 
            then you shouldn't be calling this initializer.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.Inflate(System.Int32)">
      <summary>
            Inflate the data in the InputBuffer, placing the result in the OutputBuffer.
            </summary>
      <remarks>
            You must have set InputBuffer and OutputBuffer, NextIn and NextOut, and AvailableBytesIn and 
            AvailableBytesOut  before calling this method.</remarks>
      <param name="f">I think you want to set this to Z_NO_FLUSH.</param>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.EndInflate">
      <summary>
            Ends an inflation session. 
            </summary>
      <remarks>
            Call this after successively calling Inflate().  This will cause all buffers to be flushed. 
            After calling this you cannot call Inflate() without a intervening call to one of the
            InitializeInflate() overloads.
            </remarks>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SyncInflate">
      <summary>
            I don't know what this does!
            </summary>
      <returns>Z_OK if everything goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate">
      <summary>
            Initialize the ZlibCodec for deflation operation.
            </summary>
      <remarks>
            The codec will use the MAX window bits and the default level of compression.
            </remarks>
      <example>
        <code>
             int bufferSize = 40000;
             byte[] CompressedBytes = new byte[bufferSize];
             byte[] DecompressedBytes = new byte[bufferSize];
             
             ZlibCodec compressor = new ZlibCodec();
             
             compressor.InitializeDeflate(CompressionLevel.DEFAULT);
             
             compressor.InputBuffer = System.Text.ASCIIEncoding.ASCII.GetBytes(TextToCompress);
             compressor.NextIn = 0;
             compressor.AvailableBytesIn = compressor.InputBuffer.Length;
             
             compressor.OutputBuffer = CompressedBytes;
             compressor.NextOut = 0;
             compressor.AvailableBytesOut = CompressedBytes.Length;
             
             while (compressor.TotalBytesIn != TextToCompress.Length &amp;&amp; compressor.TotalBytesOut &lt; bufferSize)
             {
               compressor.Deflate(ZlibConstants.Z_NO_FLUSH);
             }
             
             while (true)
             {
               int rc= compressor.Deflate(ZlibConstants.Z_FINISH);
               if (rc == ZlibConstants.Z_STREAM_END) break;
             }
             
             compressor.EndDeflate();
              
            </code>
      </example>
      <returns>Z_OK if all goes well. You generally don't need to check the return code.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel.
            </summary>
      <remarks>
            The codec will use the MAX window bits and the specified CompressionLevel.
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
      <remarks>
            The codec will use the MAX window bits and the specified CompressionLevel.
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            and the specified number of window bits. 
            </summary>
      <remarks>
            The codec will use the specified number of window bits and the specified CompressionLevel.
            </remarks>
      <param name="level">The compression level for the codec.</param>
      <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.InitializeDeflate(Ionic.Zlib.CompressionLevel,System.Int32,System.Boolean)">
      <summary>
            Initialize the ZlibCodec for deflation operation, using the specified CompressionLevel, 
            the specified number of window bits, and the explicit flag governing whether to emit an RFC1950 header byte pair.
            </summary>
      <param name="level">The compression level for the codec.</param>
      <param name="wantRfc1950Header">whether to emit an initial RFC1950 byte pair in the compressed stream.</param>
      <param name="bits">the number of window bits to use.  If you don't know what this means, don't use this method.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.Deflate(System.Int32)">
      <summary>
            Deflate one batch of data.
            </summary>
      <remarks>
            You must have set InputBuffer and OutputBuffer before calling this method.
            </remarks>
      <param name="flush">whether to flush all data as you deflate. Generally you will want to 
            use Z_NO_FLUSH here, in a series of calls to Deflate(), and then call EndDeflate() to 
            flush everything. 
            </param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.EndDeflate">
      <summary>
            End a deflation session.
            </summary>
      <remarks>
            Call this after making a series of one or more calls to Deflate(). All buffers are flushed.
            </remarks>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SetDeflateParams(Ionic.Zlib.CompressionLevel,Ionic.Zlib.CompressionStrategy)">
      <summary>
            Set the CompressionStrategy and CompressionLevel for a deflation session.
            </summary>
      <param name="level">the level of compression to use.</param>
      <param name="strategy">the strategy to use for compression.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="M:Ionic.Zlib.ZlibCodec.SetDictionary(System.Byte[])">
      <summary>
            Set the dictionary to be used for either Inflation or Deflation.
            </summary>
      <param name="dictionary">The dictionary bytes to use.</param>
      <returns>Z_OK if all goes well.</returns>
    </member>
    <member name="P:Ionic.Zlib.ZlibCodec.Adler32">
      <summary>
            The Adler32 checksum on the data transferred through the codec so far. You probably don't need to look at this.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.DeflateStream">
      <summary>
            A class for compressing and decompressing streams using the Deflate algorithm.
            </summary>
      <remarks>
        <para>
            Data can be compressed or decompressed, and either of those can be through reading or writing. 
            For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE Compressed Data 
            Format Specification version 1.3." 
            </para>
        <para>
            This class is similar to <see cref="T:Ionic.Zlib.ZlibStream" />, except that <c>ZlibStream</c> adds the RFC1950 
            header bytes to a compressed stream when compressing, or expects the RFC1950 header bytes when 
            decompressing. The <c>DeflateStream</c> does not.
            </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
      <summary>
            Create a DeflateStream using the specified CompressionMode.
            </summary>
      <remarks>
            The DeflateStream will use the default compression level.
            </remarks>
      <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n= -1;
                        while (n != 0)
                        {
                            if (n &gt; 0) 
                                compressor.Write(buffer, 0, n);
                            n= input.Read(buffer, 0, buffer.Length);
                        }
                    }
                }
            }
            </code><code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
            	Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress)
            	    Dim buffer As Byte() = New Byte(4096) {}
            	    Dim n As Integer = -1
            	    Do While (n &lt;&gt; 0)
            		If (n &gt; 0) Then
            		    compressor.Write(buffer, 0, n)
            		End If
            		n = input.Read(buffer, 0, buffer.Length)
            	    Loop
            	End Using
                End Using
            End Using
            </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
      <summary>
            Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel.
            </summary>
      <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new DeflateStream(raw,
                                                                 CompressionMode.Compress, 
                                                                 CompressionLevel.BEST_COMPRESSION))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n= -1;
                        while (n != 0)
                        {
                            if (n &gt; 0) 
                                compressor.Write(buffer, 0, n);
                            n= input.Read(buffer, 0, buffer.Length);
                        }
                    }
                }
            }
            </code><code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
            	Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, CompressionLevel.BEST_COMPRESSION)
            	    Dim buffer As Byte() = New Byte(4096) {}
            	    Dim n As Integer = -1
            	    Do While (n &lt;&gt; 0)
            		If (n &gt; 0) Then
            		    compressor.Write(buffer, 0, n)
            		End If
            		n = input.Read(buffer, 0, buffer.Length)
            	    Loop
            	End Using
                End Using
            End Using
            </code></example>
      <param name="stream">The stream to be read or written while deflating or inflating.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
      <summary>
            Create a DeflateStream using the specified CompressionMode, and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
      <remarks>
        <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
        <para>
            The DeflateStream will use the default compression level.
            </para>
        <para>
            See the other overloads of this constructor for example code.
            </para>
      </remarks>
      <param name="stream">The stream which will be read or written. This is called the 
            "captive" stream in other places in this documentation.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
            Create a DeflateStream using the specified CompressionMode and the specified CompressionLevel, 
            and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
      <remarks>
        <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
      </remarks>
      <example>
            This example shows how to use a DeflateStream to compress data.
            <code>
            using (System.IO.Stream input = System.IO.File.OpenRead(fileToCompress))
            {
                using (var raw = System.IO.File.Create(outputFile))
                {
                    using (Stream compressor = new DeflateStream(raw, CompressionMode.Compress, true))
                    {
                        byte[] buffer = new byte[WORKING_BUFFER_SIZE];
                        int n= -1;
                        while (n != 0)
                        {
                            if (n &gt; 0) 
                                compressor.Write(buffer, 0, n);
                            n= input.Read(buffer, 0, buffer.Length);
                        }
                    }
                }
            }
            </code><code lang="VB">
            Dim outputFile As String = (fileToCompress &amp; ".compressed")
            Using input As Stream = File.OpenRead(fileToCompress)
                Using raw As FileStream = File.Create(outputFile)
            	Using compressor As Stream = New DeflateStream(raw, CompressionMode.Compress, True)
            	    Dim buffer As Byte() = New Byte(4096) {}
            	    Dim n As Integer = -1
            	    Do While (n &lt;&gt; 0)
            		If (n &gt; 0) Then
            		    compressor.Write(buffer, 0, n)
            		End If
            		n = input.Read(buffer, 0, buffer.Length)
            	    Loop
            	End Using
                End Using
            End Using
            </code></example>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the DeflateStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Close">
      <summary>
            Close the stream.  
            </summary>
      <remarks>
            This may or may not close the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read data from the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the DeflateStream to compress data while reading, you can create a DeflateStream with 
            CompressionMode.Compress, providing an uncompressed data stream.  Then call Read() on that DeflateStream, 
            and the data read will be compressed. 
            If you wish to use the DeflateStream to decompress data while reading, you can create a DeflateStream with 
            CompressionMode.Decompress, providing a readable compressed data stream.  Then call Read() on that DeflateStream, 
            and the data read will be decompressed. 
            </para>
        <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
      </remarks>
      <param name="buffer">The buffer into which the read data should be placed.</param>
      <param name="offset">the offset within that data array to put the first byte read.</param>
      <param name="count">the number of bytes to read.</param>
      <returns>the number of bytes actually read</returns>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Calling this method always throws a <see cref="T:System.NotImplementedException" />.
            </summary>
      <param name="offset">this is irrelevant, since it will always throw!</param>
      <param name="origin">this is irrelevant, since it will always throw!</param>
      <returns>irrelevant!</returns>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.SetLength(System.Int64)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
      <param name="value">this is irrelevant, since it will always throw!</param>
    </member>
    <member name="M:Ionic.Zlib.DeflateStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write data to the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the DeflateStream to compress data while writing, you can create a DeflateStream with 
            CompressionMode.Compress, and a writable output stream.  Then call Write() on that DeflateStream, 
            providing uncompressed data as input.  The data sent to the output stream will be the compressed form of the data written.
            If you wish to use the DeflateStream to decompress data while writing, you can create a DeflateStream with 
            CompressionMode.Decompress, and a writable output stream.  Then call Write() on that stream, providing previously 
            compressed data. The data sent to the output stream will be the decompressed form of the data written.   
            </para>
        <para>
            A DeflateStream can be used for Read() or Write(), but not both. 
            </para>
      </remarks>
      <param name="buffer">The buffer holding data to write to the stream.</param>
      <param name="offset">the offset within that data array to find the first byte to write.</param>
      <param name="count">the number of bytes to write.</param>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.FlushMode">
      <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.BufferSize">
      <summary>
            Callers can set the buffer size of the working buffer with this property.  
            </summary>
      <remarks>
            The working buffer is used for all stream operations.
            The default size is 1024 bytes.  The minimum size is 128 bytes. You may get better 
            performance with a larger buffer.  Then again, you might not.  I don't know, I haven't tested it.  
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.TotalIn">
      <summary> Returns the total number of bytes input so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.TotalOut">
      <summary> Returns the total number of bytes output so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanRead">
      <summary>
            Indicates whether the stream can be read.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanSeek">
      <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
      <remarks>
            Always returns false.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.CanWrite">
      <summary>
            Indicates whether the stream can be written.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.Length">
      <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.DeflateStream.Position">
      <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.ZlibStream">
      <summary>
            Represents a Zlib stream for compression or decompression.
            </summary>
      <remarks>
        <para>
            Data can be compressed or decompressed, and either of those can be through reading or writing. 
            For more information on the Deflate algorithm, see IETF RFC 1951, "DEFLATE Compressed Data 
            Format Specification version 1.3." 
            </para>
        <para>
            This class is similar to <see cref="T:Ionic.Zlib.DeflateStream" />, except that it adds the RFC1950 header 
            bytes to a compressed stream when compressing, or expects the RFC1950 header bytes when 
            decompressing.
            </para>
      </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode)">
      <summary>
            Create a ZlibStream using the specified CompressionMode.
            </summary>
      <remarks>
        <para>
            The ZlibStream will use the default compression level.
            </para>
        <para>
            See the documentation for the <see cref="T:Ionic.Zlib.DeflateStream" /> constructors for example code.
            </para>
      </remarks>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel)">
      <summary>
            Create a ZlibStream using the specified CompressionMode and the specified CompressionLevel.
            </summary>
      <remarks>
            See the documentation for the <see cref="T:Ionic.Zlib.DeflateStream" /> constructors for example code.
            </remarks>
      <param name="stream">The stream to be read or written while deflating or inflating.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,System.Boolean)">
      <summary>
            Create a ZlibStream using the specified CompressionMode, and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
      <remarks>
        <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
        <para>
            The ZlibStream will use the default compression level.
            </para>
        <para>
            See the documentation for the <see cref="T:Ionic.Zlib.DeflateStream" /> constructors for example code.
            </para>
      </remarks>
      <param name="stream">The stream which will be read or written. This is called the 
            "captive" stream in other places in this documentation.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.#ctor(System.IO.Stream,Ionic.Zlib.CompressionMode,Ionic.Zlib.CompressionLevel,System.Boolean)">
      <summary>
            Create a ZlibStream using the specified CompressionMode and the specified CompressionLevel, 
            and explicitly specify whether
            the stream should be left open after Deflation or Inflation.
            </summary>
      <remarks>
        <para>
            This constructor allows the application to request that the captive stream remain open after
            the deflation or inflation occurs.  By default, after Close() is called on the stream, the 
            captive stream is also closed. In some cases this is not desired, for example if the stream 
            is a memory stream that will be re-read after compression.  Specify true for the 
            leaveOpen parameter to leave the stream open. 
            </para>
        <para>
            See the documentation for the <see cref="T:Ionic.Zlib.DeflateStream" /> constructors for example code.
            </para>
      </remarks>
      <param name="stream">The stream which will be read or written.</param>
      <param name="mode">Indicates whether the ZlibStream will compress or decompress.</param>
      <param name="leaveOpen">true if the application would like the stream to remain open after inflation/deflation.</param>
      <param name="level">A tuning knob to trade speed for effectiveness.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Close">
      <summary>
            Close the stream.  
            </summary>
      <remarks>
            This may or may not close the captive stream. 
            See the ctor's with leaveOpen parameters for more information.
            </remarks>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Flush">
      <summary>
            Flush the stream.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Read(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Read data from the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the ZlibStream to compress data while reading, you can create a ZlibStream with 
            CompressionMode.Compress, providing an uncompressed data stream.  Then call Read() on that ZlibStream, 
            and the data read will be compressed. 
            If you wish to use the ZlibStream to decompress data while reading, you can create a ZlibStream with 
            CompressionMode.Decompress, providing a readable compressed data stream.  Then call Read() on that ZlibStream, 
            and the data read will be decompressed. 
            </para>
        <para>
            A ZlibStream can be used for Read() or Write(), but not both. 
            </para>
      </remarks>
      <param name="buffer">The buffer into which the read data should be placed.</param>
      <param name="offset">the offset within that data array to put the first byte read.</param>
      <param name="count">the number of bytes to read.</param>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.SetLength(System.Int64)">
      <summary>
            Calling this method always throws a NotImplementedException.
            </summary>
    </member>
    <member name="M:Ionic.Zlib.ZlibStream.Write(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Write data to the stream. 
            </summary>
      <remarks>
        <para>
            If you wish to use the ZlibStream to compress data while writing, you can create a ZlibStream with 
            CompressionMode.Compress, and a writable output stream.  Then call Write() on that ZlibStream, 
            providing uncompressed data as input.  The data sent to the output stream will be the compressed form of the data written.
            If you wish to use the ZlibStream to decompress data while writing, you can create a ZlibStream with 
            CompressionMode.Decompress, and a writable output stream.  Then call Write() on that stream, providing previously 
            compressed data. The data sent to the output stream will be the decompressed form of the data written.   
            </para>
        <para>
            A ZlibStream can be used for Read() or Write(), but not both. 
            </para>
      </remarks>
      <param name="buffer">The buffer holding data to write to the stream.</param>
      <param name="offset">the offset within that data array to find the first byte to write.</param>
      <param name="count">the number of bytes to write.</param>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.FlushMode">
      <summary>
            This property sets the flush behavior on the stream.  
            Sorry, though, not sure exactly how to describe all the various settings.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.BufferSize">
      <summary>
            Callers can set the buffer size of the working buffer with this property.  
            </summary>
      <remarks>
            The working buffer is used for all stream operations.
            The default size is 1024 bytes.  The minimum size is 128 bytes. You may get better 
            performance with a larger buffer.  Then again, you might not.  I don't know, I haven't tested it.  
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.TotalIn">
      <summary> Returns the total number of bytes input so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.TotalOut">
      <summary> Returns the total number of bytes output so far.</summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanRead">
      <summary>
            Indicates whether the stream can be read.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports reading.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanSeek">
      <summary>
            Indicates whether the stream supports Seek operations.
            </summary>
      <remarks>
            Always returns false.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.CanWrite">
      <summary>
            Indicates whether the stream can be written.
            </summary>
      <remarks>
            The return value depends on whether the captive stream supports writing.
            </remarks>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.Length">
      <summary>
            Reading this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="P:Ionic.Zlib.ZlibStream.Position">
      <summary>
            Reading or Writing this property always throws a NotImplementedException.
            </summary>
    </member>
    <member name="T:Ionic.Zlib.ZlibConstants">
      <summary>
            A bunch of constants used in the Zlib interface.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_NO_FLUSH">
      <summary>
            No flush at all.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_PARTIAL_FLUSH">
      <summary>
            A little bit of flush?
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_SYNC_FLUSH">
      <summary>
            Sync flush?
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_FULL_FLUSH">
      <summary>
            Full flush?
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_FINISH">
      <summary>
            Finish?
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WINDOW_BITS_MAX">
      <summary>
            The maximum number of window bits for the Deflate algorithm.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.WINDOW_BITS_DEFAULT">
      <summary>
            The default number of window bits for the Deflate algorithm.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_OK">
      <summary>
            indicates everything is A-OK
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_END">
      <summary>
            Indicates that the last operation reached the end of the stream.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_NEED_DICT">
      <summary>
            The operation ended in need of a dictionary. 
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_STREAM_ERROR">
      <summary>
            There was an error with the stream - not enough data, not open and readable, etc.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_DATA_ERROR">
      <summary>
            There was an error with the data - not enough data, bad data, etc.
            </summary>
    </member>
    <member name="F:Ionic.Zlib.ZlibConstants.Z_BUF_ERROR">
      <summary>
            There was an error with the working buffer.
            </summary>
    </member>
  </members>
</doc>